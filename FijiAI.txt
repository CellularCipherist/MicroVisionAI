===== app/routes/app_primer.json =====

{
  "backend": {
    "scripts": [
      {
        "name": "app/main.py",
        "location": "app/",
        "purpose": "Entry point to run the FastAPI application using Uvicorn.",
        "key_interactions": "Imports `app` from `app/__init__.py`."
      },
      {
        "name": "app/__init__.py",
        "location": "app/",
        "purpose": "Initializes the FastAPI app (`AtlasApplication`), sets up configurations, logging, static files, templates, routers, and event handlers. Manages ImageJ service lifecycle.",
        "key_interactions": "Imports from `config.py`, `services` module, and `routes` module (`image_routes`, `chat_routes`)."
      },
      {
        "name": "app/auth.py",
        "location": "app/",
        "purpose": "Handles user authentication using HTTP Basic Authentication.",
        "key_interactions": "Provides authentication dependencies to routes via FastAPI's `Depends`."
      },
      {
        "name": "app/database.py",
        "location": "app/",
        "purpose": "Sets up the database connection using SQLAlchemy and defines the `ImageMetadata` model.",
        "key_interactions": "Provides `get_db` for database sessions used by `image_routes.py` and other services."
      },
      {
        "name": "config.yaml",
        "location": "Project Root",
        "purpose": "Stores all configuration settings in YAML format.",
        "key_interactions": "Loaded by `config.py` and utilized by various backend scripts."
      },
      {
        "name": "app/config.py",
        "location": "app/",
        "purpose": "Manages application configurations by loading settings from `config.yaml`.",
        "key_interactions": "Loaded by multiple scripts (`__init__.py`, `auth.py`, `database.py`, `chat_routes.py`, etc.)."
      },
      {
        "name": "app/chat_routes.py",
        "location": "app/routes/",
        "purpose": "Handles chat-related API routes, including macro generation and prompt improvement with streaming capabilities.",
        "key_interactions": "Utilizes `auth.py` for authentication and interacts with `atlas_service` for AI functionalities."
      },
      {
        "name": "app/image_routes.py",
        "location": "app/routes/",
        "purpose": "Manages image-related API routes, including uploading, deleting, and executing macros on images.",
        "key_interactions": "Uses `image_service`, `imagej_service`, and interacts with `database.py` for metadata storage."
      },
      {
        "name": "app/services/__init__.py",
        "location": "app/services/",
        "purpose": "Initializes and configures services (`imagej_service`, `atlas_service`, `file_service`, `image_service`).",
        "key_interactions": "Sets dependencies like `file_service` for `imagej_service`; initializes ImageJ service."
      },
      {
        "name": "app/services/atlas_service.py",
        "location": "app/services/",
        "purpose": "Interacts with Anthropic API to generate improved prompts and ImageJ macros using streaming.",
        "key_interactions": "Utilizes `anthropic.AsyncAnthropic`, configuration from `config.py`, and predefined prompts."
      },
      {
        "name": "app/services/file_service.py",
        "location": "app/services/",
        "purpose": "Manages file operations, including waiting for file creation, creating ZIP archives, parsing logs, and cleaning up temporary files.",
        "key_interactions": "Utilized by `imagej_service.py` and `image_service.py`."
      },
      {
        "name": "app/services/image_service.py",
        "location": "app/services/",
        "purpose": "Handles image processing tasks, including running preview macros and generating image previews.",
        "key_interactions": "Interfaces with `imagej_service` and `file_service`; interacts with ImageJ via `scyjava`."
      },
      {
        "name": "app/services/imagej_service.py",
        "location": "app/services/",
        "purpose": "Manages initialization, execution, and shutdown of ImageJ service; executes ImageJ macros on uploaded images.",
        "key_interactions": "Depends on `file_service`; utilizes ImageJ and Bio-Formats via `scyjava`; interacts with `image_routes.py`."
      },
      {
        "name": "app/prompts/system_prompts.py",
        "location": "app/prompts/",
        "purpose": "Defines system-level prompts for AI interactions, guiding macro generation and prompt improvement.",
        "key_interactions": "Utilized by `atlas_service.py` and other AI-related services to ensure consistent and accurate AI responses."
      }
    ]
  },
  "frontend": {
    "scripts": [
      {
        "name": "app/templates/intext.html",
        "location": "app/templates/",
        "purpose": "Main HTML template for the frontend interface, including image upload and chat sections.",
        "key_interactions": "Links to CSS stylesheets and JavaScript modules; structures the UI for user interactions."
      },
      {
        "name": "app/static/js/main.js",
        "location": "app/static/js/",
        "purpose": "Initializes application components (sidebar, file handling, chat interface, macro script interface), sets up event listeners, and manages overall application state.",
        "key_interactions": "Imports modules like `sidebar.js`, `fileHandling.js`, `chatInterface.js`, `macroScriptInterface.js`, `eventListeners.js`, `colorSchemeSwitcher.js`."
      },
      {
        "name": "app/static/js/apiCalls.js",
        "location": "app/static/js/",
        "purpose": "Manages API calls to the backend for macro generation, prompt improvement, image upload, and deletion.",
        "key_interactions": "Utilizes Fetch API to communicate with backend routes; handles different response types (JSON, ZIP)."
      },
      {
        "name": "app/static/js/uiUpdates.js",
        "location": "app/static/js/",
        "purpose": "Manages UI updates, including displaying chat messages, macro scripts, error/success messages, and loading indicators.",
        "key_interactions": "Called by other JS modules like `chatInterface.js` for UI feedback."
      },
      {
        "name": "app/static/js/chatInterface.js",
        "location": "app/static/js/",
        "purpose": "Manages the chat interface, handling user inputs, prompt improvements, and macro generation via streaming.",
        "key_interactions": "Uses `apiCalls.js` for backend communication and `uiUpdates.js` for UI updates; interacts with sidebar for file previews."
      },
      {
        "name": "app/static/js/fileHandling.js",
        "location": "app/static/js/",
        "purpose": "Manages file upload interactions, drag-and-drop functionality, and interaction with the sidebar for displaying image previews.",
        "key_interactions": "Uses `apiCalls.js` and `uiUpdates.js` for backend communication and UI feedback; interfaces with `sidebar.js`."
      },
      {
        "name": "app/static/js/macroScriptInterface.js",
        "location": "app/static/js/",
        "purpose": "Handles macro script submissions, image uploads associated with macros, and result processing.",
        "key_interactions": "Utilizes `apiCalls.js` for uploading and downloading; interacts with `uiUpdates.js` for displaying results."
      },
      {
        "name": "app/static/js/eventListeners.js",
        "location": "app/static/js/",
        "purpose": "Sets up event listeners for various UI interactions, ensuring elements are properly referenced and handlers are correctly bound.",
        "key_interactions": "Interfaces with `sidebar.js`, `fileHandling.js`, `chatInterface.js`, `macroScriptInterface.js`."
      },
      {
        "name": "app/static/js/colorSchemeSwitcher.js",
        "location": "app/static/js/",
        "purpose": "Manages color scheme switching functionality, allowing users to select and persist UI color themes.",
        "key_interactions": "Interacts with the color scheme selection dropdown in `intext.html`; updates CSS variables based on selection."
      },
      {
        "name": "app/static/js/sidebar.js",
        "location": "app/static/js/",
        "purpose": "Manages sidebar functionality, including image preview management and sidebar toggling.",
        "key_interactions": "Interfaces with `fileHandling.js` for displaying image previews; updates UI elements accordingly."
      },
      {
        "name": "app/static/js/utils.js",
        "location": "app/static/js/",
        "purpose": "Provides utility functions like adjusting textarea height for better UI responsiveness.",
        "key_interactions": "Imported by other JS modules for shared utility functions."
      },
      {
        "name": "app/static/css/main.css",
        "location": "app/static/css/",
        "purpose": "Main CSS stylesheet importing other CSS modules and defining base styles and theme transitions.",
        "key_interactions": "Styles the entire frontend interface, including fonts, colors, and responsive design."
      },
      {
        "name": "app/static/css/chat.css",
        "location": "app/static/css/",
        "purpose": "Styles chat components, including chat containers, message bubbles, and interactive elements.",
        "key_interactions": "Applied to chat-related HTML elements for layout and visual consistency."
      },
      {
        "name": "app/static/css/drag-drop.css",
        "location": "app/static/css/",
        "purpose": "Styles the drag-and-drop zone for file uploads, including hover effects and responsive design.",
        "key_interactions": "Applied to the drop zone in `intext.html` to enhance user interaction during file uploads."
      },
      {
        "name": "app/static/css/layout.css",
        "location": "app/static/css/",
        "purpose": "Defines the overall layout of the application, including main containers, columns, and responsive behavior.",
        "key_interactions": "Applied to structural HTML elements in `intext.html` to manage the positioning and sizing of components."
      },
      {
        "name": "app/static/css/message.css",
        "location": "app/static/css/",
        "purpose": "Styles chat message bubbles for outputs and user inputs, with different themes and transitions.",
        "key_interactions": "Applied to chat message elements to differentiate between system, user, and output messages."
      },
      {
        "name": "app/static/css/macro-script.css",
        "location": "app/static/css/",
        "purpose": "Styles the macro script display area, including syntax highlighting and action buttons.",
        "key_interactions": "Applied to macro script windows in the chat interface for better readability and interactivity."
      },
      {
        "name": "app/static/css/color-scheme-selector.css",
        "location": "app/static/css/",
        "purpose": "Styles the color scheme selector dropdown, ensuring it integrates seamlessly with the overall UI.",
        "key_interactions": "Applied to the color scheme selection component in `intext.html` to provide a consistent look and feel."
      },
      {
        "name": "app/static/css/sidebar.css",
        "location": "app/static/css/",
        "purpose": "Styles the sidebar, including toggling states, image previews, and interactive elements.",
        "key_interactions": "Applied to sidebar HTML elements to manage visibility and layout of image previews."
      },
      {
        "name": "app/static/css/responsive.css",
        "location": "app/static/css/",
        "purpose": "Ensures the application is responsive across different screen sizes and devices.",
        "key_interactions": "Utilized across various components to maintain usability and aesthetics on mobile and desktop views."
      },
      {
        "name": "app/static/css/utilities.css",
        "location": "app/static/css/",
        "purpose": "Provides utility classes for common styling needs, such as margins, paddings, and display properties.",
        "key_interactions": "Used by various HTML elements to apply consistent spacing and layout without redundant CSS."
      }
    ]
  },
  "key_enhancements": {
    "route_naming_conventions": {
      "consistent_naming": "Ensure that all backend API routes follow a consistent naming convention (e.g., snake_case or kebab-case).",
      "descriptive_endpoints": "Names should clearly describe the action or resource.",
      "versioning": "Incorporate API versioning to manage changes without disrupting existing frontend functionalities.",
      "avoid_renaming_critical_routes": {
        "simultaneous_updates": "All frontend references are updated concurrently.",
        "aliases_or_redirects": "Utilize aliases or redirect routes temporarily to prevent breaking changes.",
        "backward_compatibility": "Maintain backward compatibility for a transitional period."
      },
      "centralized_route_definitions": {
        "backend": "Define all routes in a single location (e.g., app/routes.py).",
        "frontend": "Define all routes in a single location (e.g., app/static/js/routes.js)."
      }
    },
    "preventing_route_renaming_issues": {
      "documentation": "Maintain up-to-date documentation of all API endpoints.",
      "automated_testing": "Implement integration tests that verify the connectivity between frontend API calls and backend routes.",
      "linting_static_analysis": "Use linters or static analysis tools to catch inconsistencies between frontend and backend route references.",
      "continuous_integration": "Set up CI pipelines that run tests ensuring any changes to routes are validated against frontend expectations."
    },
    "comprehensive_documentation_standards": {
      "comprehensive_docstrings": "Ensure that all functions, classes, and modules have clear and descriptive docstrings.",
      "readme_api_documentation": "Maintain a README.md summarizing the application and generate API documentation using tools like Swagger or ReDoc.",
      "change_logs": "Implement a changelog to track modifications, especially those related to API routes or critical functionalities."
    },
    "error_handling_enhancements": {
      "centralized_error_management": "Implement a centralized error handler in FastAPI.",
      "frontend_error_handling": "Ensure that frontend components gracefully handle API errors."
    },
    "scalability_modularity": {
      "modular_codebase": "Organize code into well-defined modules and packages.",
      "service_decoupling": "Design services to operate independently, minimizing tight coupling and facilitating parallel development."
    }
  }
}


===== app/routes/chat_routes.py =====

from fastapi import APIRouter, Request, Depends, Query, HTTPException
from fastapi.responses import JSONResponse
from sse_starlette.sse import EventSourceResponse
from typing import AsyncGenerator
import json
import logging

from ..auth import get_current_username
from ..services.atlas_service import generate_improved_prompt, generate_macro_from_prompt

router = APIRouter()
logger = logging.getLogger(__name__)

# Helper function to format EventSource messages as JSON
def format_event(event_type: str, data: dict) -> str:
    return json.dumps({"event": event_type, "data": data})

async def stream_improved_prompt(input: str) -> AsyncGenerator[str, None]:
    try:
        async for chunk in generate_improved_prompt(input):
            yield format_event("improved_prompt_chunk", {"chunk": chunk})
        yield format_event("improved_prompt_complete", {"message": "Prompt improvement complete"})
    except Exception as e:
        logger.error(f"Error in prompt improvement streaming: {str(e)}")
        yield format_event("error", {"error": str(e)})

@router.get("/stream-improve-prompt/")
async def stream_improve_prompt(
    request: Request,
    input: str = Query(..., min_length=1, description="Input for prompt improvement"),
    username: str = Depends(get_current_username)
) -> EventSourceResponse:
    return EventSourceResponse(stream_improved_prompt(input))

async def macro_stream(
    request: Request, input: str, improve_prompt: bool
) -> AsyncGenerator[str, None]:
    try:
        prompt = input
        # Improve prompt if needed
        if improve_prompt:
            async for improved_chunk in generate_improved_prompt(input):
                yield format_event("improved_prompt_chunk", {"chunk": improved_chunk})
            yield format_event("improved_prompt_complete", {"message": "Prompt improvement complete"})
            prompt = improved_chunk  # Use last chunk as final improved prompt

        async for event in generate_macro_from_prompt(prompt):
            if await request.is_disconnected():
                logger.info("Client disconnected. Closing stream.")
                break
            yield format_event(event['event'], event['data'])

    except Exception as e:
        logger.error(f"Error generating macro: {str(e)}")
        yield format_event("error", {"error": str(e)})

@router.get("/stream-generate-macro/")
async def stream_generate_macro(
    request: Request,
    input: str = Query(..., min_length=1, description="Input for macro generation"),
    improve_prompt: bool = Query(False, description="Flag to enhance the prompt"),
    username: str = Depends(get_current_username)
) -> EventSourceResponse:
    return EventSourceResponse(macro_stream(request, input, improve_prompt))


===== app/routes/image_routes.py =====

from fastapi import APIRouter, File, UploadFile, BackgroundTasks, Depends, HTTPException, Form
from fastapi.responses import JSONResponse, StreamingResponse
from sqlalchemy.orm import Session
import os
import shutil
import tempfile
import logging
import aiofiles
from app.services import image_service, imagej_service
from app.database import get_db, ImageMetadata
from app.config import load_config
from typing import List

logger = logging.getLogger(__name__)
config = load_config()

class ImageRouteHandler:
    def __init__(self, image_service, imagej_service):
        """
        Handles image-related routes, including uploading, deleting, and executing macros on images.
        """
        self.image_service = image_service
        self.imagej_service = imagej_service
        self.logger = logger

    async def upload_image(
        self,
        background_tasks: BackgroundTasks,
        files: List[UploadFile] = File(...),
        execute_macro: bool = Form(False),
        macro_script: str = Form(None),
        db: Session = Depends(get_db)
    ) -> JSONResponse:
        """
        Handles uploading of images, with optional macro execution.
        """
        self.logger.info(f"Received files: {[file.filename for file in files]}")

        if not files:
            raise HTTPException(status_code=400, detail="No files uploaded")

        try:
            if execute_macro and macro_script:
                return await self.handle_execute_macro(files, macro_script, background_tasks)
            else:
                return await self.handle_initial_upload(files, background_tasks, db)
        except HTTPException as he:
            db.rollback()
            self.logger.error(f"HTTPException during processing files: {str(he)}", exc_info=True)
            raise he
        except Exception as e:
            db.rollback()
            self.logger.error(f"Error processing files: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail="Error processing files.")

    async def handle_initial_upload(
        self,
        files: List[UploadFile],
        background_tasks: BackgroundTasks,
        db: Session
    ) -> JSONResponse:
        """
        Handles the initial upload of images without macro execution.
        """
        results = []
        for file in files:
            temp_dir = tempfile.mkdtemp()
            try:
                original_path = os.path.join(temp_dir, file.filename)
                async with aiofiles.open(original_path, "wb") as buffer:
                    await buffer.write(await file.read())
                self.logger.info(f"Saved original file to: {original_path}")

                processed_data = await self.image_service.process_image(
                    original_path, background_tasks, file.filename
                )
                preview = await self.image_service.generate_image_preview(processed_data['preview_path'])

                db_metadata = ImageMetadata(
                    file_name=processed_data['unique_filename'],
                    original_path=processed_data['original_path'],
                    preview_path=processed_data['preview_path'],
                    image_metadata=processed_data['metadata'],
                    file_type=processed_data['file_type']
                )
                db.add(db_metadata)
                db.commit()

                self.logger.info(f"Successfully processed and saved file: {file.filename}")

                results.append({
                    "filename": file.filename,
                    "unique_filename": processed_data['unique_filename'],
                    "preview": preview,
                    "metadata": processed_data['metadata'],
                    "file_type": processed_data['file_type']
                })

            except Exception as e:
                self.logger.error(f"Error processing file {file.filename}: {str(e)}", exc_info=True)
                db.rollback()
                results.append({
                    "filename": file.filename,
                    "error": str(e)
                })
            finally:
                background_tasks.add_task(shutil.rmtree, temp_dir)

        return JSONResponse(content={"results": results})

    async def delete_image(
        self,
        filename: str,
        db: Session = Depends(get_db)
    ) -> JSONResponse:
        """
        Deletes an image and its metadata from the database and file system.
        """
        try:
            image_metadata = db.query(ImageMetadata).filter(ImageMetadata.file_name == filename).first()
            if not image_metadata:
                raise HTTPException(status_code=404, detail="Image not found")

            # Delete files if they exist
            for path in [image_metadata.original_path, image_metadata.preview_path]:
                if os.path.exists(path):
                    os.remove(path)
                    self.logger.info(f"Deleted file: {path}")

            db.delete(image_metadata)
            db.commit()
            return JSONResponse(content={"message": "Image deleted successfully"})
        except Exception as e:
            db.rollback()
            self.logger.error(f"Error deleting image {filename}: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail="Error deleting image.")

    async def handle_execute_macro(
        self,
        files: List[UploadFile],
        macro_script: str,
        background_tasks: BackgroundTasks
    ) -> StreamingResponse:
        """
        Executes a macro script on the uploaded images and returns the results as a ZIP file.
        """
        self.logger.info("Executing macro script...")
        zip_path, error_logs = await self.imagej_service.execute_image_macro(
            files, macro_script, {}, background_tasks
        )

        if zip_path and os.path.exists(zip_path):
            self.logger.info(f"Macro executed successfully, results stored at: {zip_path}")

            async def iterfile():
                async with aiofiles.open(zip_path, mode="rb") as file_like:
                    chunk = await file_like.read(1024 * 1024)
                    while chunk:
                        yield chunk
                        chunk = await file_like.read(1024 * 1024)

            return StreamingResponse(
                iterfile(),
                media_type="application/zip",
                headers={"Content-Disposition": f"attachment; filename=results.zip"}
            )
        else:
            self.logger.error("Failed to execute macro or generate results ZIP")
            raise HTTPException(status_code=500, detail="Failed to execute macro.")

    async def get_image_preview(
        self,
        filename: str,
        db: Session = Depends(get_db)
    ) -> JSONResponse:
        """
        Fetches a base64-encoded preview image for the given filename.
        """
        try:
            image_metadata = db.query(ImageMetadata).filter(ImageMetadata.file_name == filename).first()
            if not image_metadata or not os.path.exists(image_metadata.preview_path):
                raise HTTPException(status_code=404, detail="Preview not found")

            preview = await self.image_service.generate_image_preview(image_metadata.preview_path)
            return JSONResponse(content={"preview": preview})

        except Exception as e:
            self.logger.error(f"Error generating image preview for {filename}: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail="Error generating image preview.")

# Instantiate the handler
image_handler = ImageRouteHandler(image_service, imagej_service)

# Define the API router and map routes to handler methods
router = APIRouter()
router.get("/get-image-preview/{filename}")(image_handler.get_image_preview)
router.post("/upload-image/")(image_handler.upload_image)
router.delete("/delete-image/{filename}")(image_handler.delete_image)


===== app/services/atlas_service.py =====

"""
Atlas service module for the FastAPI application.
Handles interactions with the Anthropic API for generating improved prompts and ImageJ macros using streaming.
"""

from anthropic import AsyncAnthropic
from anthropic.types import ContentBlockDeltaEvent
from typing import List, Dict, AsyncGenerator, Any
from fastapi import HTTPException
import logging

from ..config import load_config
from ..prompts.system_prompts import (
    PROMPT_IMPROVEMENT_SYSTEM,
    PROMPT_IMPROVEMENT_USER,
    MACRO_GENERATION_PROMPT
)

# Load configuration and initialize the Anthropic client
config = load_config()
client = AsyncAnthropic(api_key=config.get('api_keys.anthropic'))
logger = logging.getLogger(__name__)

async def generate_improved_prompt(user_input: str) -> AsyncGenerator[str, None]:
    """
    Generates an improved prompt using the Anthropic API with streaming.

    Args:
        user_input (str): The original user input that needs improvement.

    Yields:
        str: Chunks of the improved prompt generated by the AI.

    Raises:
        HTTPException: If there's an error in generating the improved prompt.

    Example:
        async for chunk in generate_improved_prompt("Enhance this prompt for clarity."):
            print(chunk)  # Outputs chunks of the enhanced prompt.
    """
    try:
        async with client.messages.stream(
            model=config.get('claude.model'),
            max_tokens=config.get('claude.max_tokens'),
            temperature=0,
            system=PROMPT_IMPROVEMENT_SYSTEM,
            messages=[
                {"role": "user", "content": PROMPT_IMPROVEMENT_USER.format(user_input=user_input)}
            ]
        ) as stream:
            async for event in stream.text_stream:
                yield event
    except Exception as e:
        logger.error(f"Error generating improved prompt: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to generate improved prompt")

async def generate_macro_from_prompt(prompt: str) -> AsyncGenerator[Dict[str, Any], None]:
    """
    Generates an ImageJ macro script based on the given prompt using the Anthropic API with streaming.

    This function streams the generated content, handling transitions between different sections
    (description, macro script, and explanation) to maintain a structured output.

    Args:
        prompt (str): The user-provided prompt for generating the macro script.

    Yields:
        Dict[str, Any]: Event data indicating content updates, section changes, or completion status.

    Example:
        async for event in generate_macro_from_prompt("Analyze cell images to count nuclei"):
            print(event)  # Prints streaming events related to macro generation.

    Raises:
        HTTPException: If an error occurs during the macro generation process.
    """
    user_prompt = (
        f"Generate an ImageJ macro script that accomplishes this task:\n\n"
        f"{prompt}\n\n"
        "Ensure all sections (description, macro script, and explanation) are properly formatted."
    )

    try:
        current_section = "description"
        section_content = ""

        async with client.messages.stream(
            model=config.get('claude.model'),
            max_tokens=config.get('claude.max_tokens'),
            temperature=0,
            system=MACRO_GENERATION_PROMPT,
            messages=[{"role": "user", "content": user_prompt}]
        ) as stream:
            yield {"event": "section_change", "data": {"section": current_section, "content": section_content}}

            async for event in stream:
                if isinstance(event, ContentBlockDeltaEvent):
                    content_chunk = event.delta.text
                    section_content += content_chunk

                    if handle_section_transition(content_chunk, current_section):
                        for change_event in process_section_change(current_section, section_content):
                            yield change_event
                        current_section = get_next_section(current_section)
                        section_content = ""
                    else:
                        yield {
                            "event": "message",
                            "data": {"content": content_chunk, "section": current_section}
                        }

        if section_content:
            yield {
                "event": "section_change",
                "data": {"section": current_section, "content": section_content.strip()}
            }

        yield {"event": "complete", "data": {"message": "Macro generation complete"}}

    except Exception as e:
        logger.error(f"Error generating macro: {str(e)}", exc_info=True)
        yield {"event": "error", "data": {"error": str(e)}}
        raise HTTPException(status_code=500, detail="Failed to generate macro script")

def handle_section_transition(content: str, current_section: str) -> bool:
    """
    Determines if the content indicates a transition to a new section.

    Args:
        content (str): The current content chunk.
        current_section (str): The current section being processed.

    Returns:
        bool: True if a section transition is detected, False otherwise.
    """
    if "```" in content:
        return current_section in ["description", "macro_script"]
    return False

def get_next_section(current_section: str) -> str:
    """
    Determines the next section based on the current section.

    Args:
        current_section (str): The current section.

    Returns:
        str: The name of the next section.
    """
    section_order = ["description", "macro_script", "explanation"]
    current_index = section_order.index(current_section)
    return section_order[(current_index + 1) % len(section_order)]

def process_section_change(current_section: str, content: str) -> List[Dict[str, Any]]:
    """
    Processes a section change and returns the appropriate event.

    Args:
        current_section (str): The current section that is ending.
        content (str): The content of the section.

    Returns:
        List[Dict[str, Any]]: A list containing an event indicating the section change and its content.
    """
    cleaned_content = clean_section_content(current_section, content)
    return [{
        "event": "section_change",
        "data": {"section": current_section, "content": cleaned_content.strip()}
    }]

def clean_section_content(section: str, content: str) -> str:
    """
    Cleans the content of a section based on its type.

    Args:
        section (str): The type of section (e.g., "macro_script", "description", "explanation").
        content (str): The raw content of the section.

    Returns:
        str: The cleaned content.
    """
    content = content.replace("[DESCRIPTION]", "").replace("[EXPLANATION]", "").strip()
    if section == "macro_script":
        # Remove anything before the first "//" for macro scripts
        code_start = content.find("//")
        return content[code_start:] if code_start != -1 else content
    return content


===== app/services/file_service.py =====

import os
import zipfile
import logging
import asyncio
import aiofiles
from typing import List, Optional
import shutil
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

class FileService:
    def __init__(self):
        """
        Service class for handling file operations in the FastAPI application.
        """
        self.logger = logger

    async def wait_for_file(
        self,
        file_path: str,
        timeout: int = 60,
        check_interval: float = 0.5
    ) -> bool:
        """
        Waits asynchronously for a file to be created and written.

        Args:
            file_path (str): Path to the file to wait for.
            timeout (int): Maximum time to wait in seconds.
            check_interval (float): Interval between checks in seconds.

        Returns:
            bool: True if the file exists and is non-empty, False otherwise.
        """
        end_time = asyncio.get_event_loop().time() + timeout
        while asyncio.get_event_loop().time() < end_time:
            if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
                return True
            await asyncio.sleep(check_interval)
        self.logger.warning(f"Timeout reached while waiting for file: {file_path}")
        return False

    async def create_zip_file(
        self,
        file_paths: List[str],
        zip_filename: str
    ) -> Optional[str]:
        """
        Creates a zip file containing the specified files.

        Args:
            file_paths (List[str]): List of file paths to include in the zip.
            zip_filename (str): Name of the zip file to create.

        Returns:
            Optional[str]: Path to the created zip file, or None if creation failed.
        """
        if not file_paths:
            self.logger.warning("No files provided to zip.")
            return None

        def zip_files():
            try:
                seen_files = set()
                with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in file_paths:
                        if not os.path.exists(file_path):
                            self.logger.warning(f"File not found, skipping: {file_path}")
                            continue
                        if file_path in seen_files:
                            self.logger.warning(f"Duplicate file detected, skipping: {file_path}")
                            continue

                        arcname = os.path.relpath(file_path, os.path.dirname(zip_filename))
                        zipf.write(file_path, arcname)
                        seen_files.add(file_path)
                        self.logger.info(f"Added file to zip: {arcname}")

                if os.path.exists(zip_filename):
                    zip_size = os.path.getsize(zip_filename)
                    self.logger.info(f"Zip file created: {zip_filename}, Size: {zip_size} bytes")
                    return zip_filename
                else:
                    self.logger.error(f"Zip file not found after creation: {zip_filename}")
                    return None
            except Exception as e:
                self.logger.error(f"Error creating zip file: {str(e)}", exc_info=True)
                return None

        loop = asyncio.get_event_loop()
        with ThreadPoolExecutor() as executor:
            return await loop.run_in_executor(executor, zip_files)

    async def parse_saved_files(
        self,
        output: str,
        temp_dir: str,
        original_filename: str
    ) -> List[str]:
        """
        Parses the output log and collects saved files.

        Args:
            output (str): Output log from the ImageJ macro.
            temp_dir (str): Temporary directory where files are saved.
            original_filename (str): Original filename of the processed image.

        Returns:
            List[str]: List of file paths for saved files.
        """
        files = set()
        log_file = os.path.join(temp_dir, "output_log.txt")
        if os.path.exists(log_file):
            async with aiofiles.open(log_file, 'r') as f:
                async for line in f:
                    line = line.strip()
                    if line.startswith("OUTPUT_FILE:"):
                        file_path = line[len("OUTPUT_FILE:"):].strip().replace('//', '/')
                        file_path = os.path.normpath(file_path)
                        if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
                            files.add(file_path)
                            self.logger.info(f"Found valid output file: {file_path}")
                        else:
                            self.logger.warning(f"Logged file not found or empty: {file_path}")

        # Collect files from all subdirectories under temp_dir
        for root, _, filenames in os.walk(temp_dir):
            for filename in filenames:
                if filename.startswith(original_filename):
                    file_path = os.path.join(root, filename)
                    if os.path.getsize(file_path) > 0:
                        files.add(file_path)
                    else:
                        self.logger.warning(f"Empty file found and skipped: {file_path}")

        if not files:
            self.logger.warning(f"No valid files found for {original_filename}.")

        self.logger.info(f"Parsed saved files: {list(files)}")
        return list(files)

    async def cleanup_temp_files(self, path: str, delay: int = 300):
        """
        Cleans up temporary files and directories after a delay.

        Args:
            path (str): Path to the temporary file or directory.
            delay (int): Delay in seconds before cleanup.
        """
        await asyncio.sleep(delay)
        try:
            if os.path.isdir(path):
                shutil.rmtree(path)
                self.logger.info(f"Deleted temporary directory: {path}")
            elif os.path.isfile(path):
                os.remove(path)
                self.logger.info(f"Deleted temporary file: {path}")
            else:
                self.logger.warning(f"Path not found for deletion: {path}")
        except Exception as e:
            self.logger.error(f"Error deleting temporary path {path}: {str(e)}", exc_info=True)

file_service = FileService()


===== app/services/image_service.py =====

import os
import io
import base64
import tempfile
import logging
import uuid
import asyncio
import scyjava
from typing import Dict, Tuple
from fastapi import HTTPException, BackgroundTasks
from PIL import Image, UnidentifiedImageError
from app.services import imagej_service, file_service
from ..config import load_config

class ImageService:
    def __init__(self):
        self.config = load_config()
        self.logger = logging.getLogger(__name__)

    def _load_macro_template(self, input_path: str, output_dir: str, filename: str, output_log_path: str) -> str:
        template_path = self.config.get('paths.conversion_template')
        if not os.path.exists(template_path):
            raise RuntimeError(f"Macro template does not exist at: {template_path}")

        with open(template_path, 'r') as template_file:
            macro_template = template_file.read()

        try:
            formatted_macro = macro_template.format(
                input_path=input_path.replace('\\', '/'),
                output_dir=output_dir.replace('\\', '/'),
                filename=os.path.splitext(filename)[0],
                output_log_path=output_log_path.replace('\\', '/')
            )
        except KeyError as e:
            self.logger.error(f"Error formatting macro template: {e}")
            raise RuntimeError(f"Macro template formatting error: {e}")

        return formatted_macro

    async def process_image(self, original_path: str, background_tasks: BackgroundTasks, filename: str) -> Dict:
        self.logger.info(f"Processing image: {filename}")

        try:
            file_uuid = str(uuid.uuid4())
            unique_filename = f"{file_uuid}_{filename}"
            result = await self.run_preview_macro(original_path, os.path.dirname(original_path), unique_filename, background_tasks)

            return {
                'metadata': result['metadata'],
                'preview_path': result['preview_path'],
                'original_path': original_path,
                'file_type': os.path.splitext(filename)[1][1:],
                'unique_filename': unique_filename
            }
        except Exception as e:
            self.logger.error(f"Failed to process image: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail=f"Failed to process image: {str(e)}")

    async def run_preview_macro(self, input_path: str, output_dir: str, filename: str, background_tasks: BackgroundTasks) -> Dict:
        self.logger.info(f"Running headless preview macro for file: {filename}")

        temp_dir = tempfile.mkdtemp()
        output_log_path = os.path.join(temp_dir, "output_log.txt")

        try:
            IJ, BF = imagej_service.get_imagej_objects()
            user_macro = self._load_macro_template(input_path, output_dir, filename, output_log_path)

            self.logger.info("Executing macro script...")
            output = IJ.runMacro(user_macro)
            output = scyjava.to_python(output) if output is not None else ""
            self.logger.info(f"Macro output: {output}")

            # Wait for the log file to be created and written
            log_content = await self._wait_for_file_content(output_log_path, timeout=60)

            metadata, preview_path = self._extract_paths_from_log(log_content)

            # Wait for the preview file to be created
            await self._wait_for_file(preview_path, timeout=120)

            if not os.path.exists(preview_path):
                raise ValueError(f"Preview image was not generated or found at: {preview_path}")

            return {
                'metadata': metadata,
                'preview_path': preview_path
            }

        except Exception as e:
            self.logger.error(f"Error in run_preview_macro: {str(e)}", exc_info=True)
            if os.path.exists(output_log_path):
                with open(output_log_path, 'r') as log_file:
                    self.logger.error(f"Output log file contents: {log_file.read()}")
            raise HTTPException(status_code=500, detail=f"Failed to generate preview: {str(e)}")
        finally:
            background_tasks.add_task(file_service.cleanup_temp_files, temp_dir)

    async def _wait_for_file(self, file_path: str, timeout: int = 120, check_interval: float = 1.0) -> None:
        start_time = asyncio.get_event_loop().time()
        while not os.path.exists(file_path):
            if asyncio.get_event_loop().time() - start_time > timeout:
                raise TimeoutError(f"File not created within {timeout} seconds: {file_path}")
            await asyncio.sleep(check_interval)

        # Additional check for file size
        file_size = 0
        for _ in range(10):  # Check file size stability for 10 seconds
            current_size = os.path.getsize(file_path)
            if current_size > 0 and current_size == file_size:
                return  # File size is stable and non-zero
            file_size = current_size
            await asyncio.sleep(1)

        if file_size == 0:
            raise ValueError(f"File created but empty: {file_path}")

    async def _wait_for_file_content(self, file_path: str, timeout: int = 60, check_interval: float = 1.0) -> str:
        start_time = asyncio.get_event_loop().time()
        content = ""
        while not content:
            if asyncio.get_event_loop().time() - start_time > timeout:
                raise TimeoutError(f"File content not available within {timeout} seconds: {file_path}")
            try:
                with open(file_path, 'r') as file:
                    content = file.read().strip()
            except (FileNotFoundError, PermissionError):
                pass
            if not content:
                await asyncio.sleep(check_interval)
        return content

    def _extract_paths_from_log(self, log_content: str) -> Tuple[Dict, str]:
        metadata_path = None
        preview_path = None
        metadata = {}

        for line in log_content.split('\n'):
            line = line.strip()
            if line.startswith('METADATA_PATH:'):
                metadata_path = line.split(':', 1)[1].strip()
            elif line.startswith('PREVIEW_PATH:'):
                preview_path = line.split(':', 1)[1].strip()

        if metadata_path and os.path.exists(metadata_path):
            with open(metadata_path, 'r') as f:
                metadata = {'raw': f.read()}
        else:
            self.logger.warning(f"Metadata file not found at expected path: {metadata_path}")

        return metadata, preview_path

    async def generate_image_preview(self, file_path: str) -> str:
        try:
            with Image.open(file_path) as img:
                img = img.convert('RGB') if img.mode not in ['RGB', 'L'] else img
                img.thumbnail((200, 200))
                buffer = io.BytesIO()
                img.save(buffer, format="PNG")
                img_str = base64.b64encode(buffer.getvalue()).decode()
                return f"data:image/png;base64,{img_str}"
        except UnidentifiedImageError:
            self.logger.error(f"Failed to identify image format for file: {file_path}")
            raise HTTPException(status_code=400, detail="Failed to identify the image format.")
        except Exception as e:
            self.logger.error(f"Failed to generate image preview: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail=f"Failed to generate image preview: {str(e)}")

# Initialize the service
image_service = ImageService()


===== app/services/imagej_service.py =====

import os
import logging
import time
import asyncio
import aiofiles
import tempfile
from typing import List, Tuple, Optional
from fastapi import UploadFile, BackgroundTasks, HTTPException
from werkzeug.utils import secure_filename
import imagej
import jpype
import scyjava
import sys
import shutil
from ..config import load_config
from app.services import file_service

logger = logging.getLogger(__name__)

class ImageJService:
    def set_file_service(self, file_service):
        self.file_service = file_service
    def __init__(self):
        """
        Service class for handling ImageJ operations.
        """
        self.config = load_config()
        self.ij = None
        self.IJ = None
        self.BF = None
        self.logger = logger
        self.file_service = file_service

    def initialize(self, retries: int = 3, delay: int = 5):
        """
        Initializes ImageJ with the given configuration.
        """
        for attempt in range(1, retries + 1):
            try:
                self.logger.info("Initializing ImageJ...")
                self.logger.debug(f"Python version: {sys.version}")
                self.logger.debug(f"JPype version: {jpype.__version__}")
                self.logger.debug(f"ImageJ version: {imagej.__version__}")

                start_time = time.time()

                self._configure_java_options()

                imagej_dir = self.config.get('paths.imagej_dir')
                self.logger.info(f"ImageJ directory: {imagej_dir}")

                self.ij = imagej.init(imagej_dir, mode='headless')
                self.logger.info("JVM started successfully")

                self.ij.ui().setHeadless(True)
                self.IJ, self.BF = self._import_imagej_classes()

                self._log_version_info()

                elapsed_time = time.time() - start_time
                self.logger.info(f"ImageJ initialized successfully in {elapsed_time:.2f} seconds.")
                break
            except Exception as e:
                self.logger.error(f"Failed to initialize ImageJ (Attempt {attempt}/{retries}): {str(e)}", exc_info=True)
                if attempt < retries:
                    self.logger.info(f"Retrying ImageJ initialization in {delay} seconds...")
                    time.sleep(delay)
                else:
                    self.logger.error("Exceeded maximum retries for ImageJ initialization.")
                    raise RuntimeError(f"Failed to initialize ImageJ after {retries} attempts.") from e

    def _configure_java_options(self):
        """
        Configures Java options for ImageJ initialization.
        """
        scyjava.config.add_option('-Xmx16g')
        scyjava.config.add_option('-Djava.awt.headless=true')

        bf_jar = self.config.get('paths.bioformats_dir')
        scyjava.config.add_classpath(bf_jar)

    def _import_imagej_classes(self) -> Tuple[object, object]:
        """
        Imports necessary ImageJ classes.

        Returns:
            Tuple[object, object]: The IJ module and BF module from ImageJ.
        """
        try:
            IJ = scyjava.jimport('ij.IJ')
            BF = scyjava.jimport('loci.plugins.BF')
            self.logger.info("ImageJ and Bio-Formats plugins imported successfully")
            return IJ, BF
        except Exception as e:
            self.logger.error(f"Failed to import ImageJ classes: {str(e)}", exc_info=True)
            raise

    def get_imagej_objects(self) -> Tuple[object, object]:
        """
        Returns the IJ and BF objects if they are initialized.

        Returns:
            Tuple[object, object]: The IJ and BF objects.

        Raises:
            RuntimeError: If ImageJ has not been initialized.
        """
        if not self.IJ or not self.BF:
            raise RuntimeError("ImageJ has not been initialized. Call initialize() first.")
        return self.IJ, self.BF

    def _log_version_info(self):
        """
        Logs version information for ImageJ and Bio-Formats.
        """
        self.logger.info(f"Fiji version: {self.ij.getVersion()}")
        bf_version = scyjava.jimport('loci.formats.FormatTools').VERSION
        self.logger.info(f"Bio-Formats version: {bf_version}")

    def shutdown(self):
        """
        Shuts down ImageJ and cleans up resources.
        """
        if self.ij:
            self.ij.context().dispose()
            self.ij = None
            self.logger.info("ImageJ context disposed.")
        self.IJ = None
        self.BF = None
        self.logger.info("ImageJ shut down successfully.")

    async def execute_image_macro(
        self,
        files: List[UploadFile],
        macro_script: str,
        macro_params: dict,
        background_tasks: BackgroundTasks
    ) -> Tuple[str, List[str]]:
        """
        Executes a macro script on the uploaded images and returns the results as a ZIP file.

        Args:
            files (List[UploadFile]): List of uploaded image files.
            macro_script (str): The macro script to execute.
            macro_params (dict): Parameters for the macro.
            background_tasks (BackgroundTasks): Background tasks for cleanup.

        Returns:
            Tuple[str, List[str]]: Path to the ZIP file and a list of error logs.
        """
        if not self.file_service:
            raise RuntimeError("FileService is not initialized.")

        self.logger.info(f"Starting macro execution on {len(files)} files.")
        error_logs = []
        output_files = []
        temp_dir = tempfile.mkdtemp()

        try:
            # Create subdirectories
            subdirs = ['Images', 'Statistics', 'Metadata']
            for subdir in subdirs:
                os.makedirs(os.path.join(temp_dir, subdir), exist_ok=True)

            for file in files:
                image_filename = secure_filename(file.filename)
                original_filename = os.path.splitext(image_filename)[0]
                image_path = os.path.join(temp_dir, image_filename)
                await self._save_upload_file(file, image_path)

                try:
                    self.logger.info(f"Processing image: {image_path}")
                    full_macro = self._prepare_macro_script(
                        image_path, temp_dir, original_filename, macro_script, macro_params
                    )

                    # Execute the macro
                    output = self.IJ.runMacro(full_macro) or self.IJ.getLog() or ""
                    self.logger.debug(f"Macro output:\n{output}")

                    # Parse saved files
                    saved_files = await self.file_service.parse_saved_files(output, temp_dir, original_filename)
                    self.logger.info(f"Saved files for {image_filename}: {saved_files}")
                    output_files.extend(saved_files)

                except Exception as e:
                    error_message = f"Error processing {image_filename}: {str(e)}"
                    error_logs.append(error_message)
                    self.logger.error(error_message, exc_info=True)

            if output_files:
                self.logger.info(f"Creating ZIP file with {len(output_files)} files.")
                zip_filename = os.path.join(temp_dir, 'results.zip')
                zip_path = await self.file_service.create_zip_file(output_files, zip_filename)
                if zip_path and os.path.exists(zip_path):
                    self.logger.info(f"ZIP file created successfully: {zip_path}")
                    return zip_path, error_logs
                else:
                    error_message = "Failed to create zip file."
                    self.logger.error(error_message)
                    error_logs.append(error_message)
                    raise HTTPException(status_code=500, detail=error_message)
            else:
                error_message = "No output files were generated."
                self.logger.error(error_message)
                error_logs.append(error_message)
                raise HTTPException(status_code=500, detail=error_message)

        finally:
            # Cleanup temporary files after the response is sent
            background_tasks.add_task(self.file_service.cleanup_temp_files, temp_dir)

    def _prepare_macro_script(
        self,
        image_path: str,
        temp_dir: str,
        original_filename: str,
        user_macro: str,
        macro_params: dict
    ) -> str:
        """
        Prepares the full macro script with variable definitions and user macro.

        Args:
            image_path (str): Path to the input image.
            temp_dir (str): Temporary directory for outputs.
            original_filename (str): Original filename without extension.
            user_macro (str): User-provided macro script.
            macro_params (dict): Macro parameters.

        Returns:
            str: The full macro script ready for execution.
        """

        var_definitions = f"""
        var inputPath = "{image_path}";
        var outputDir = "{temp_dir}{os.path.sep}";
        var originalFileName = "{original_filename}";
        var minSize = {macro_params.get('minSize', 10)};
        var maxSize = "{macro_params.get('maxSize', 'Infinity')}";
        var minCircularity = {macro_params.get('minCircularity', 0.00)};
        var maxCircularity = {macro_params.get('maxCircularity', 1.00)};
        """        # Load and modify macro template

        macro_template_path = self.config.get('paths.macro_template')
        with open(macro_template_path, 'r') as template_file:
            macro_template = template_file.read()

        full_macro = var_definitions + macro_template.replace("{user_macro}", user_macro or "")
        self.logger.debug(f"Full macro script:\n{full_macro}")
        return full_macro

    async def _save_upload_file(self, file: UploadFile, destination: str):
        """
        Saves an uploaded file to the specified destination.

        Args:
            file (UploadFile): The uploaded file.
            destination (str): The destination path to save the file.
        """
        try:
            async with aiofiles.open(destination, 'wb') as out_file:
                await out_file.write(await file.read())
            self.logger.info(f"File saved successfully: {destination}")
        except Exception as e:
            self.logger.error(f"Failed to save uploaded file to {destination}: {str(e)}", exc_info=True)
            raise

imagej_service = ImageJService()
imagej_service.set_file_service(file_service)


===== app/static/css/chat.css =====

/**
 * Main chat container styles for layout and alignment.
 * Uses flexbox for vertical stacking of child elements.
 */
.chat-container {
    display: flex;
    /* Flexible box layout for adaptability */
    flex-direction: column;
    /* Stacks child elements vertically */
    height: 100%;
    /* Full height for container to occupy entire space */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring container height is consistent across different screen sizes for full usability. */
}

/* Chat Log Styling */
.chat-log {
    flex-grow: 1;
    /* Allows the chat log to expand */
    max-height: calc(100vh - 200px);
    /* Limits height to leave space for chat input */
    overflow-y: auto;
    /* Enables scrolling for overflow content */
    padding: 15px;
    margin-bottom: 10px;
    background: var(--color-white-05);
    border-radius: 10px;
    box-sizing: border-box;
    transition: max-height 0.3s ease;
}


/**
 * Individual chat message container.
 * Handles alignment and smooth transitions for displaying messages.
 */
.chat-message {
    display: flex;
    /* Uses flex for easy alignment of messages */
    flex-direction: column;
    /* Stacks sender and message content vertically */
    margin-bottom: 15px;
    /* Space below each message for readability */
    transition: all 0.3s ease;
    /* Smooth transition for new messages */
    /*.................................................................................................................*/
    /* Reflecting: Checking how smooth transitions affect the loading and removal of messages to keep flow natural. */
}

/**
 * Styling for the sender's name within a message.
 * Bold styling to differentiate from message content.
 */
.chat-message span {
    font-weight: bold;
    /* Differentiates sender name with bold styling */
    margin-bottom: 5px;
    /* Space between sender name and message */
    /*.................................................................................................................*/
    /* Reflecting: Reviewing consistency in spacing and boldness for sender names across different themes. */
}

/**
 * Message content area within a chat message.
 * Uses smooth transitions and wraps long words or lines.
 */
.chat-message .message-content {
    background-color: var(--color-white-05);
    /* Matches log background for uniformity */
    padding: 10px;
    /* Inner spacing for message content */
    border-radius: 8px;
    /* Rounded corners for a unified design */
    white-space: pre-wrap;
    /* Preserves formatting of whitespace */
    word-wrap: break-word;
    /* Ensures long words wrap to fit */
    transition: all 0.3s ease;
    /* Smooth visual transitions */
    /*.................................................................................................................*/
    /* Reflecting: Verifying that all message contents render correctly with proper wrapping and no overflow issues. */
}

/**
 * Styles for both output and user input bubbles.
 * Includes common styles for padding, width, and word wrapping.
 */
.output-bubble,
.user-input-bubble {
    width: 100%;
    /* Full width utilization for uniformity */
    max-width: 100%;
    /* Prevents overflow beyond parent */
    padding: 15px;
    /* Padding inside message bubbles */
    border-radius: 15px;
    /* Rounded corners for bubble shape */
    position: relative;
    /* Allows for easy positioning of elements within */
    overflow: hidden;
    /* Hides overflow for a clean look */
    margin-bottom: 15px;
    /* Space below each bubble for separation */
    word-wrap: break-word;
    /* Prevents overflow from long words */
    transition: all 0.3s ease;
    /* Smooth animations on changes */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring bubble resizing and transitions remain smooth, even with variable message lengths. */
}

/**
 * Styles specifically for the output message bubble.
 * Aligns to the start of the container with a slightly darker background.
 */
.output-bubble {
    background-color: var(--color-white-10);
    /* Darker shade for distinguishing output */
    align-self: flex-start;
    /* Aligns bubble to the start */
    /*.................................................................................................................*/
    /* Reflecting: Confirming consistent alignment for output bubbles, keeping user perspective in mind. */
}

/**
 * Styles specifically for the user input message bubble.
 * Uses accent color and primary text color for user inputs.
 */
.user-input-bubble {
    background-color: var(--accent-color-dark);
    /* Uses accent color for user bubbles */
    color: var(--text-primary);
    /* Ensures primary text color is readable */
    align-self: flex-end;
    /* Aligns input bubbles to the right */
    transition: background-color 0.3s ease;
    /* Smooth transition for visual feedback */
    /*.................................................................................................................*/
    /* Reflecting: Checking visual contrast and readability of user input bubbles across themes. */
}

.macro-script-window {
    width: 100%;
    /* Full width to integrate smoothly with layout */
    background-color: var(--dark-background);
    /* Ensures dark mode consistency */
    border-radius: 8px;
    /* Rounded edges for visual coherence */
    margin-top: 10px;
    /* Space above macro script window */
    overflow: hidden;
    /* Prevents content overflow */
    color: var(--text-primary-light);
    /* Uses light text for readability */
    transition: all 0.3s ease;
    /* Smooth transitions on updates */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring macro script windows are fully responsive and maintain readability. */
}

/* Ensure any dark mode classes from index.html are properly applied */
body.dark-mode .macro-script-window {
    background-color: #1e1e1e;
    /* Matches dark mode styling */
    color: #d4d4d4;
    /* Light text for contrast */
    /*.................................................................................................................*/
    /* Reflecting: Consistency check with dark mode styling to ensure user interface looks seamless. */
}

/**
 * Header section of the macro script window.
 * Bold, white text on a slightly lighter background.
 */
.macro-script-header {
    background-color: #252526;
    /* Sets background lighter than main area */
    color: #ffffff;
    /* White text for header */
    padding: 10px;
    /* Adds padding around header text */
    font-weight: bold;
    /* Bold text for emphasis */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring that header visibility and text prominence are adequate under various lighting conditions. */
}

/**
 * Content area of the macro script window for displaying code.
 * Manages vertical scrolling and ensures correct font for code readability.
 */
.macro-script-content {
    padding: 10px;
    /* Padding for inner content spacing */
    max-height: 800px;
    /* Restricts height to prevent excessive overflow */
    overflow-y: auto;
    /* Enables vertical scrolling */
    font-family: 'Consolas', 'Courier New', monospace;
    /* Monospace for code clarity */
    position: relative;
    /* Allows for positioning pseudo-elements */
    /*.................................................................................................................*/
    /* Reflecting: Evaluating content rendering consistency, especially under different coding styles and themes. */
}

/**
 * Pseudo-element indicating streaming state.
 * Only visible when content is streaming to show activity.
 */
.macro-script-content.streaming::after {
    content: '';
    /* Visual indicator for activity */
    position: absolute;
    /* Positions element relative to parent */
    bottom: 0;
    /* Aligns to bottom */
    right: 0;
    /* Aligns to right */
    width: 10px;
    /* Sets width */
    height: 10px;
    /* Sets height */
    background-color: #0e639c;
    /* Matches the theme color */
    border-radius: 50%;
    /* Circular shape */
    animation: blink 1s infinite;
    /* Blinking animation */
    display: block;
    /* Displayed when streaming */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring indicator visibility and alignment don't interfere with other UI elements. */
}

/**
 * Action buttons within the macro script window.
 * Flex layout to align buttons to the right with consistent padding.
 */
.macro-script-actions {
    display: flex;
    /* Flex layout for button arrangement */
    justify-content: flex-end;
    /* Aligns buttons to the right */
    padding: 10px;
    /* Inner padding around buttons */
    background-color: #252526;
    /* Matches macro script header background */
    /*.................................................................................................................*/
    /* Reflecting: Reviewing button alignment and accessibility within the macro script area for user ease. */
}

/**
 * Styles for action buttons within macro script.
 * Smooth background color transition on hover for interaction feedback.
 */
.macro-script-actions button {
    margin-left: 10px;
    /* Space between buttons */
    padding: 5px 10px;
    /* Inner padding for buttons */
    background-color: #0e639c;
    /* Button color matches theme */
    color: #ffffff;
    /* White text for contrast */
    border: none;
    /* Removes border */
    border-radius: 4px;
    /* Rounded corners */
    cursor: pointer;
    /* Pointer cursor on hover */
    transition: background-color 0.3s ease;
    /* Smooth color transition on hover */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring hover states provide clear feedback without disrupting usability. */
}

/**
 * Hover effect for macro script action buttons.
 * Darker blue background on hover for clear visual feedback.
 */
.macro-script-actions button:hover {
    background-color: #1177bb;
    /* Darker blue on hover */
    /*.................................................................................................................*/
    /* Reflecting: Hover feedback needs to be noticeable without being overwhelming or inconsistent. */
}

/**
 * Styles for streaming content with opacity changes.
 * Used to indicate content that is actively being streamed.
 */
.streaming-content {
    opacity: 0.7;
    /* Reduces opacity to show activity */
    transition: opacity 0.3s ease;
    /* Smooth transition */
    /*.................................................................................................................*/
    /* Reflecting: Balancing visual feedback for active streaming without losing content readability. */
}

.streaming-complete {
    opacity: 1;
    /* Fully opaque when streaming is complete */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring the final state clearly indicates the end of streaming with full visibility. */
}

/**
 * Loading indicator for asynchronous actions.
 * Hidden by default, shown during loading states.
 */
.loading-indicator {
    display: none;
    /* Hidden by default */
    text-align: center;
    /* Centered text alignment */
    padding: 10px;
    /* Padding for inner spacing */
    /*.................................................................................................................*/
    /* Reflecting: Loading indicators need to be clearly visible when active but unobtrusive when hidden. */
}

.loading-indicator.visible {
    display: block;
    /* Shown during loading */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring loading state transitions smoothly to improve user perception of performance. */
}

/**
 * Updated styles for the chat input container and its elements.
 * Flex layout for easy interaction between input and buttons.
 */
.chat-input-container {
    background-color: var(--input-background);
    /* Consistent background for input area */
    border-radius: 8px;
    /* Rounded corners for input container */
    border: 1px solid var(--border-color);
    /* Border using theme color */
    padding: 10px;
    /* Padding inside container */
    display: flex;
    /* Flex layout for inputs and buttons */
    align-items: center;
    /* Aligns items vertically */
    justify-content: space-between;
    /* Spreads items apart evenly */
    transition: box-shadow 0.3s ease;
    /* Smooth shadow transition */
    margin-bottom: 0px;
    /* Removes bottom margin to fit within overall layout */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring input containers are functional and visually aligned within the app layout. */
}

/**
 * Focus styles for input container.
 * Adds shadow for clear visual focus feedback.
 */
.chat-input-container:focus-within {
    box-shadow: 0 0 15px var(--accent-color);
    /* Highlight when focused for user clarity */
    /*.................................................................................................................*/
    /* Reflecting: Visual feedback on focus states should enhance usability without being overly dramatic. */
}

/**
 * Textarea within chat input container.
 * Expandable with no resize and clear focus transitions.
 */
.chat-input-container textarea {
    flex-grow: 1;
    /* Expands to fill available space within container */
    background: none;
    /* Transparent background for unified design */
    border: none;
    /* Removes border to fit design language */
    color: var(--text-primary);
    /* Primary text color for readability */
    resize: none;
    /* Disables resizing to maintain layout integrity */
    min-height: 80px;
    /* Minimum height for usability */
    max-height: 300px;
    /* Limits height to prevent overflow */
    padding: 5px;
    /* Inner padding */
    font-size: 14px;
    /* Sets font size */
    transition: border-color 0.3s ease;
    /* Smooth transition for focus feedback */
    /*.................................................................................................................*/
    /* Reflecting: Balancing usability of textarea while preventing excessive height variations that could disrupt the layout. */
}

/**
 * Focus styles for textarea.
 * Removes default outline to match custom design.
 */
.chat-input-container textarea:focus {
    outline: none;
    /* Removes default outline for cleaner focus effect */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring focus states are clear but visually consistent with the app’s overall theme. */
}

/**
 * Adjusted attach button with a 2:4 ratio for consistent sizing.
 */
#attach-btn {
    background: none;
    /* No background for a clean look */
    border: none;
    /* No border */
    cursor: pointer;
    /* Pointer cursor for interactive feel */
    padding: 5px;
    /* Padding around the button */
    display: flex;
    /* Flex layout for centering */
    align-items: center;
    /* Centers button contents */
    justify-content: center;
    /* Centers button contents */
    width: 20px;
    /* Sets button width */
    height: 40px;
    /* Sets button height */
    transition: transform 0.3s ease;
    /* Smooth transform effect on interaction */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring button sizing is appropriate across device types for touch and click interactions. */
}

/**
 * Attach button image adjustments.
 * Ensures images maintain aspect ratio and transitions smoothly.
 */
#attach-btn img {
    width: 100%;
    /* Full width to fit button */
    height: auto;
    /* Maintains aspect ratio */
    transition: transform 0.3s ease;
    /* Smooth scaling on hover */
    /*.................................................................................................................*/
    /* Reflecting: Consistency in image rendering within the button boundaries, especially for different image sources. */
}

/**
 * Styles for the submit button.
 * Consistent sizing and positioning with smooth interactions.
 */
#chat-submit-btn {
    background: none;
    /* Removes background for seamless integration */
    border: none;
    /* No border */
    cursor: pointer;
    /* Interactive cursor */
    padding: 5px;
    /* Padding around button */
    display: flex;
    /* Flexbox for layout management */
    align-items: center;
    /* Centered alignment */
    justify-content: center;
    /* Centered alignment */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring button interactions are consistent across different parts of the app to avoid user confusion. */
}

/**
 * Submit button image adjustments.
 * Provides visual feedback on hover with scaling effect.
 */
#chat-submit-btn img {
    width: 30px;
    /* Set width for image */
    height: 30px;
    /* Set height for image */
    transition: transform 0.3s ease;
    /* Smooth transform on hover */
    /*.................................................................................................................*/
    /* Reflecting: Confirming the visibility and feedback of submit actions, ensuring the user can clearly see the response. */
}

/**
 * Hover effects for the attach and submit buttons.
 * Enlarges images on hover for clear user interaction.
 */
#attach-btn:hover img,
#chat-submit-btn:hover img {
    transform: scale(1.2);
    /* Enlarges images for feedback */
    /*.................................................................................................................*/
    /* Reflecting: Consistent hover feedback across interactive elements to enhance user interaction intuitively. */
}

/**
 * Container for the 'Improve Prompt' checkbox.
 * Flex layout to align items and maintain spacing.
 */
.improve-prompt-container {
    display: flex;
    /* Flex layout for alignment */
    align-items: center;
    /* Centers items vertically */
    margin-left: 10px;
    /* Spacing to the left of checkbox */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring prompt enhancements fit well within the broader UI layout and functionality. */
}

/**
 * Checkbox for improving prompt with proper spacing.
 */
#improve-prompt {
    margin-right: 5px;
    /* Spacing to the right of the checkbox */
    /*.................................................................................................................*/
    /* Reflecting: Checkboxes should be easy to interact with and not crowd adjacent elements. */
}

/**
 * Label for the 'Improve Prompt' checkbox.
 * Ensures readability and interactive cursor.
 */
#improve-prompt+label {
    font-size: 14px;
    /* Readable font size */
    color: #666;
    /* Text color for readability */
    cursor: pointer;
    /* Pointer cursor for interactivity */
    /*.................................................................................................................*/
    /* Reflecting: Ensuring labels are clear, readable, and easily associated with their checkboxes. */
}

/**
 * Animation for new content highlights.
 * Provides a subtle fade from a highlight color to transparent.
 */
@keyframes highlight {
    0% {
        background-color: rgba(255, 255, 255, 0.1);
        /* Start with a light highlight */
    }

    100% {
        background-color: transparent;
        /* Ends with no highlight */
    }

    /*.................................................................................................................*/
    /* Reflecting: Animation provides clear, subtle feedback to the user without being disruptive. */
}

/**
 * Blinking animation for indicators.
 * Used to show activity or streaming state.
 */
@keyframes blink {
    0% {
        opacity: 0;
        /* Starts invisible */
    }

    50% {
        opacity: 1;
        /* Fully visible at midpoint */
    }

    100% {
        opacity: 0;
        /* Ends invisible */
    }

    /*.................................................................................................................*/
    /* Reflecting: Blinking effect needs to be noticeable but not overly distracting to avoid user fatigue. */
}

/**
 * Class for highlighting new content with animation.
 * Smooth fade transition to emphasize updates.
 */
.new-content {
    animation: highlight 1s ease-out;
    /* Applies the highlight animation */
    /*.................................................................................................................*/
    /* Reflecting: Ensures the new content is clearly highlighted, drawing user attention to updates. */
}


===== app/static/css/color-scheme-selector.css =====

.color-scheme-selector {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
    text-align: center;
    background-color: var(--input-background);
    padding: 12px 18px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    /* Reflect: Ensure the selector integrates with overall design language for coherence */
}

.color-scheme-selector select {
    padding: 10px 14px;
    font-size: 14px;
    color: var(--text-primary);
    background-color: var(--input-background);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    cursor: pointer;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
    /* Reflect: Transitions add responsiveness and improve interaction feedback */
}

.color-scheme-selector select:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 8px var(--accent-color);
    /* Reflect: Visual feedback during focus state enhances usability */
}


===== app/static/css/colors.css =====

/* Default color scheme */
body {
--primary: #00FFFF;
    --secondary: #1E90FF;
    --highlight: #FF00FF;
    --success-color: #32CD32;
    --error-color: #FF4500;
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --color-white-05: #FFFFFF0D;
    --color-white-10: #FFFFFF1A;
    --color-white-20: #FFFFFF33;
    --color-black-70: #000000B3;
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Complementary Color Scheme */
.complementary {
    --primary: #007ACC;
    /* Blue */
    --secondary: #FF5722;
    /* Orange */
    --highlight: #FFD700;
    /* Gold */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Analogous Color Scheme */
.analogous {
    --primary: #007ACC;
    /* Blue */
    --secondary: #1E90FF;
    /* Dodger Blue */
    --highlight: #00FFFF;
    /* Aqua */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Triadic Color Scheme */
.triadic {
    --primary: #FF4500;
    /* Orange Red */
    --secondary: #32CD32;
    /* Lime Green */
    --highlight: #1E90FF;
    /* Dodger Blue */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Split-Complementary Color Scheme */
.split-complementary {
    --primary: #007ACC;
    /* Blue */
    --secondary: #FF4500;
    /* Orange Red */
    --highlight: #FFD700;
    /* Gold */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Monochromatic Color Scheme */
.monochromatic {
    --primary: #1E90FF;
    /* Dodger Blue */
    --secondary: #4682B4;
    /* Steel Blue */
    --highlight: #87CEFA;
    /* Light Sky Blue */
    --success-color: #00BFFF;
    /* Deep Sky Blue */
    --error-color: #1E90FF;
    /* Dodger Blue */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #4682B4;
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Nature-Inspired Color Scheme */
.nature {
    --primary: #556B2F;
    /* Dark Olive Green */
    --secondary: #8FBC8F;
    /* Dark Sea Green */
    --highlight: #ADFF2F;
    /* Green Yellow */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #2E8B57;
    /* Sea Green */
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Pastel Color Scheme */
.pastel {
    --primary: #FFB6C1;
    /* Light Pink */
    --secondary: #FFE4E1;
    /* Misty Rose */
    --highlight: #FFDAB9;
    /* Peach Puff */
    --success-color: #E6E6FA;
    /* Lavender */
    --error-color: #FF69B4;
    /* Hot Pink */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #D8BFD8;
    /* Thistle */
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Vibrant Neon Color Scheme */
.neon {
    --primary: #39FF14;
    /* Neon Green */
    --secondary: #FF073A;
    /* Red Salsa */
    --highlight: #FFD700;
    /* Neon Gold */
    --success-color: #39FF14;
    /* Neon Green */
    --error-color: #FF073A;
    /* Red Salsa */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #39FF14;
    /* Neon Green */
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Warm Earthy Color Scheme */
.earthy {
    --primary: #8B4513;
    /* Saddle Brown */
    --secondary: #D2691E;
    /* Chocolate */
    --highlight: #CD853F;
    /* Peru */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #A0522D;
    /* Sienna */
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Dark Luxury Color Scheme */
.dark-luxury {
    --primary: #4B0082;
    /* Indigo */
    --secondary: #8A2BE2;
    /* Blue Violet */
    --highlight: #FFD700;
    /* Gold */
    --success-color: #32CD32;
    /* Lime Green */
    --error-color: #FF4500;
    /* OrangeRed */
    --background-dark: #0D0D0D;
    --text-primary: #FFFFFF;
    --text-secondary: #B0C4DE;
    --border-color: #6A5ACD;
    /* Slate Blue */
    --input-background: #1A1A1A;
    --accent-color: var(--primary);
    --shadow-color: #FFFFFF1A;
    --glowing-section: 0 0 10px 2px var(--highlight);
}


@media (prefers-color-scheme: dark) {
    :root {
        --background-light: #1C1C1C;
        --background-white: #2C2C2C;
        --text-primary: #ECEFF1;
        --text-secondary: #B0BEC5;
        --border-color: #37474F;
        --input-background: #263238;
    }
}

/* Default Light Mode */
body.light-mode {
    --primary: #0056b3;
    /* Darker Blue */
    --secondary: #ff6600;
    /* Bright Orange */
    --highlight: #ffc107;
    /* Golden Yellow */
    --success-color: #28a745;
    /* Dark Lime Green */
    --error-color: #dc3545;
    /* Dark Red */
    --background-light: #f8f9fa;
    /* Light Gray for backgrounds */
    --background-dark: #ffffff;
    /* Pure White */
    --text-primary: #212529;
    /* Dark Charcoal */
    --text-secondary: #495057;
    /* Medium Charcoal */
    --border-color: #ced4da;
    /* Light Gray for borders */
    --input-background: #ffffff;
    /* White for inputs */
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.1);
    /* Soft shadow for depth */
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Light Complementary Color Scheme */
.light-complementary {
    --primary: #0056b3;
    /* Balanced Blue */
    --secondary: #e36209;
    /* Rich Orange */
    --highlight: #ffdd57;
    /* Soft yet bright Yellow */
    --success-color: #32cd32;
    /* Lime Green */
    --error-color: #dc3545;
    /* Dark Red */
    --background-light: #f8f9fa;
    /* Off-white for light mode */
    --background-dark: #ffffff;
    /* Pure White */
    --text-primary: #212529;
    /* Dark Charcoal */
    --text-secondary: #495057;
    /* Medium Charcoal */
    --border-color: #adb5bd;
    /* Mid Gray */
    --input-background: #ffffff;
    /* Pure White */
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.2);
    /* Defined shadow for depth */
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Light Analogous Color Scheme */
.light-analogous {
    --primary: #007bff;
    /* Balanced Blue */
    --secondary: #1e90ff;
    /* Sky Blue */
    --highlight: #40e0d0;
    /* Turquoise */
    --success-color: #32cd32;
    /* Lime Green */
    --error-color: #ff4500;
    /* Orange Red */
    --background-light: #f8f9fa;
    /* Light Gray */
    --background-dark: #ffffff;
    /* Pure White */
    --text-primary: #212529;
    /* Dark Charcoal */
    --text-secondary: #495057;
    /* Medium Charcoal */
    --border-color: #adb5bd;
    /* Mid Gray */
    --input-background: #ffffff;
    /* White */
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.2);
    /* Medium shadow */
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Light Triadic Color Scheme */
.light-triadic {
    --primary: #007bff;
    /* Blue */
    --secondary: #ff6600;
    /* Orange */
    --highlight: #28a745;
    /* Green */
    --success-color: #28a745;
    --error-color: #dc3545;
    --background-light: #f8f9fa;
    --background-dark: #ffffff;
    --text-primary: #212529;
    --text-secondary: #495057;
    --border-color: #ced4da;
    --input-background: #ffffff;
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Light Split-Complementary Color Scheme */
.light-split-complementary {
    --primary: #007bff;
    /* Blue */
    --secondary: #28a745;
    /* Green */
    --highlight: #ffc107;
    /* Yellow */
    --success-color: #28a745;
    --error-color: #dc3545;
    --background-light: #f1f3f5;
    /* Slightly darker to enhance contrast */
    --background-dark: #ffffff;
    --text-primary: #212529;
    --text-secondary: #495057;
    --border-color: #ced4da;
    --input-background: #ffffff;
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* Light Monochromatic Color Scheme */
.light-monochromatic {
    --primary: #0056b3;
    /* Dark Blue */
    --secondary: #6c757d;
    /* Gray */
    --highlight: #ced4da;
    /* Light Gray */
    --success-color: #28a745;
    --error-color: #dc3545;
    --background-light: #e2e6ea;
    /* Lighter Gray */
    --background-dark: #ffffff;
    --text-primary: #212529;
    --text-secondary: #495057;
    --border-color: #ced4da;
    --input-background: #ffffff;
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --glowing-section: 0 0 10px 2px var(--highlight);
}

/* colors.css */

/* Light Complementary Color Scheme */
.light-complementary {
    /* Existing variables ... */
    --background-hover: rgba(240, 240, 240, 0.7); /* Example value */
    --button-background: var(--accent-color);
    --button-text: var(--text-primary);
    --success-background: var(--success-color);
    --error-background: var(--error-color);
    --sidebar-background: rgba(0, 0, 0, 0.05); /* Adjust based on light mode */
    --output-bubble-background-light: var(--color-white-10);
    --user-background: var(--accent-color);
    /* Add any other necessary variables */
}

/* Dark Mode */
.dark-mode {
    /* Existing variables ... */
    --background-hover: rgba(13, 13, 13, 0.7); /* Example value */
    --button-background: var(--accent-color);
    --button-text: var(--text-primary);
    --success-background: var(--success-color);
    --error-background: var(--error-color);
    --sidebar-background: rgba(255, 255, 255, 0.05);
    --output-bubble-background-dark: var(--color-white-10);
    --user-background: var(--accent-color);
    /* Add any other necessary variables */
}


/* Applying a similar adjustment to all light modes */
.light-mode-default,
.light-nature,
.light-pastel,
.light-neon,
.light-earthy,
.light-dark-luxury {
    --primary: #0056b3;
    --secondary: #17a2b8;
    --highlight: #ffc107;
    --success-color: #28a745;
    --error-color: #dc3545;
    --background-light: #f8f9fa;
    --background-dark: #ffffff;
    --text-primary: #212529;
    --text-secondary: #495057;
    --border-color: #ced4da;
    --input-background: #ffffff;
    --accent-color: var(--primary);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --glowing-section: 0 0 10px 2px var(--highlight);
}

@media (prefers-color-scheme: light) {
    :root {
        --background-light: #f8f9fa;
        --background-dark: #ffffff;
        --text-primary: #212529;
        --text-secondary: #495057;
        --border-color: #ced4da;
        --input-background: #ffffff;
    }
}


===== app/static/css/dark-mode.css =====

/* Dark mode styles */
body.dark-mode {
    background-color: #1e1e1e;
    color: #e0e0e0;
}

.dark-mode .chat-log {
    background-color: #2d2d2d;
}

.dark-mode .chat-message {
    background-color: #3a3a3a;
    color: #e0e0e0;
}

.dark-mode .macro-script-window {
    background-color: #2d2d2d;
    color: #e0e0e0;
}

.dark-mode .macro-script-content {
    background-color: #1e1e1e;
}

.dark-mode .macro-script-content code {
    color: #d4d4d4;
}

/* Syntax highlighting for dark mode */
.dark-mode .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #1e1e1e;
    color: #dcdcdc;
}

.dark-mode .hljs-keyword,
.dark-mode .hljs-selector-tag,
.dark-mode .hljs-tag,
.dark-mode .hljs-name {
    color: #569cd6;
}

.dark-mode .hljs-attribute,
.dark-mode .hljs-selector-id,
.dark-mode .hljs-string,
.dark-mode .hljs-selector-attr,
.dark-mode .hljs-selector-pseudo,
.dark-mode .hljs-addition {
    color: #ce9178;
}

.dark-mode .hljs-comment,
.dark-mode .hljs-quote,
.dark-mode .hljs-meta {
    color: #6a9955;
}

/* Add more syntax highlighting styles as needed */


===== app/static/css/drag-drop.css =====

/* Drag and Drop Zone */
#drop-zone {
    width: 100%;
    height: 120px;
    border: 2px dashed var(--accent-color);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 20px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    /* Reflect: Unified transition for a smoother hover effect */
}

#drop-zone:hover {
    background-color: var(--color-white-10);
    border-color: var(--success-color);
    box-shadow: var(--glowing-section);
    /* Reflect: Enhance visibility and interactivity on hover */
}

#drop-zone p {
    margin: 0;
    padding: 0 10px;
    width: 100%;
    text-align: center;
    /* Reflect: Center text for uniformity */
}


===== app/static/css/layout.css =====

/* layout.css */

/* Main Container Styling */
.container {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100vh;
    margin: 0 auto;
    padding: 2vh 2vw;
    background-color: var(--background-dark);
    box-shadow: 0 0 20px var(--shadow-color);
    border-radius: 15px;
    box-sizing: border-box;
    overflow: hidden;
}

/* Left Column (Macro Script Area) Styling */
.left-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    padding: 2vh 2vw;
    background: var(--color-white-05);
    backdrop-filter: blur(10px);
    transition: width 0.3s ease, margin-left 0.3s ease;
    border-radius: 10px;
    overflow: hidden;
    box-sizing: border-box;
    max-height: 100%;
}

/* Right Column (Main Content Area) Styling */
.right-column {
    flex: 3;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    padding: 2vh 2vw;
    background-color: var(--background-dark);
    border-radius: 10px;
    box-sizing: border-box;
    overflow: hidden;
    max-height: 100%;
}

/* Sidebar State Adjustments */
.sidebar.collapsed + .left-column {
    margin-left: 2.5%;
    width: calc(100% - 30%);
    transition: margin-left 0.3s ease, width 0.3s ease;
}

.sidebar:not(.collapsed) + .left-column {
    margin-left: 12.5%;
    width: calc(87.5% - 65px);
    transition: margin-left 0.3s ease, width 0.3s ease;
}

/* Page Title Positioning */
.page-title {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: bold;
    color: var(--text-primary);
    z-index: 10;
}

/* Specific Adjustments for 16:10 Aspect Ratio */
@media (aspect-ratio: 16/10) {
    .container {
        padding: 3vh 3vw;
    }

    .left-column,
    .right-column {
        padding: 3vh 3vw;
    }

    .page-title {
        top: 25px;
        font-size: 26px;
    }
}

/* Specific Adjustments for 16:9 Aspect Ratio */
@media (aspect-ratio: 16/9) {
    .container {
        padding: 2vh 2vw;
    }

    .left-column,
    .right-column {
        padding: 2vh 2vw;
    }

    .page-title {
        top: 20px;
        font-size: 24px;
    }
}


===== app/static/css/macro-script.css =====

/* Macro Script Container */
/* Macro Script Container */
.macro-script-container {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: flex-start;
    width: 100%;
    max-width: 100%;
    margin: var(--spacing-lg) 0;
    /* e.g., 20px */
    padding: var(--spacing-sm) 0;
    /* e.g., 10px */
    box-sizing: border-box;
    gap: var(--spacing-md);
    /* e.g., 15px */
    /* Reflect: Ensures uniform container that adapts to flex properties */
}

/* Textarea for Macro Script */
textarea#macro_script {
    width: 100%;
    max-width: 100%;
    background-color: var(--input-background);
    color: var(--text-primary);
    border: 2px solid var(--border-color);
    border-radius: var(--border-radius-8);
    padding: 15px;
    /* e.g., 15px */
    font-size: var(--font-size-sm);
    /* e.g., 14px */
    font-family: 'Consolas', 'Courier New', monospace;
    box-shadow: var(--box-shadow);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    resize: vertical;
    min-height: 200px;
    max-height: 60vh;
    overflow-y: auto;
    box-sizing: border-box;
    margin: 0;
    /* Reflect: Maintains clear and balanced layout for script editing */
}

textarea#macro_script:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 15px var(--accent-color);
    /* Reflect: Clear focus effect for user interaction */
}

/* Define border-radius-8 and box-shadow variables in utilities.css if not already defined */
:root {
    --border-radius-8: 8px;
    --box-shadow: 0 0 10px var(--glowing-section);
}

/* Upload Button */
#upload-btn {
    width: 100%;
    max-width: 100%;
    margin: 0 auto;
    padding: var(--spacing-sm) var(--spacing-lg);
    /* e.g., 10px 20px */
    background-color: var(--button-background);
    color: var(--button-text);
    border: none;
    border-radius: var(--border-radius-5);
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    text-align: center;
    box-sizing: border-box;
    /* Reflect: Button spans the full width and aligns visually with other elements */
}

/* Define button-background and button-text in color schemes */
.light-complementary {
    --button-background: var(--accent-color);
    --button-text: var(--text-primary);
}

.dark-mode {
    --button-background: var(--accent-color);
    --button-text: var(--text-primary);
}

#upload-btn:hover {
    background-color: var(--highlight);
    box-shadow: var(--glowing-section);
    /* Reflect: Consistent hover state feedback */
}

#upload-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    /* Reflect: Visual feedback for disabled state */
}

/* Macro Preview Container */
/* Macro Preview Container */
#macro-preview-container {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    /* e.g., 10px */
    width: 100%;
    margin: 0 auto;
    box-sizing: border-box;
    justify-content: flex-start;
    /* Reflect: Balanced layout for preview elements */
}

/* Success and Error Messages */
.success-message,
.error-message {
    padding: var(--spacing-md); /* e.g., 15px */
    border-radius: var(--border-radius-5);
    width: 100%;
    max-width: 100%;
    text-align: center;
    margin: var(--spacing-md) 0; /* e.g., 15px 0 */
    box-sizing: border-box;
    /* Reflect: Full width, no margin issues */
    font-size: var(--font-size-sm); /* e.g., 14px */
    line-height: var(--line-height);
}

.success-message {
    background-color: var(--success-background);
    color: var(--text-primary);
    /* Reflect: Clear, readable success feedback */
}

.error-message {
    background-color: var(--error-background);
    color: var(--text-primary);
    /* Reflect: Distinctive, readable error feedback */
}

/* Define success-background and error-background in color schemes */
.light-complementary {
    --success-background: var(--success-color);
    --error-background: var(--error-color);
}

.dark-mode {
    --success-background: var(--success-color);
    --error-background: var(--error-color);
}

/* Execution Results Container */
#execution-results {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-height: 40vh;
    overflow-y: auto;
    box-sizing: border-box;
    /* Reflect: Scalable, organized results display */
}
/* Execution Results Container */
#results-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    width: 100%;
    margin-top: var(--spacing-md);
    /* e.g., 15px */
    box-sizing: border-box;
    gap: var(--spacing-sm);
    /* e.g., 10px */
}

.result-item {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    background-color: var(--input-background);
    padding: var(--spacing-sm);
    border-radius: var(--border-radius-5);
    box-shadow: var(--box-shadow);
    width: 100%;
    box-sizing: border-box;
}

.result-item a {
    color: var(--link-color);
    text-decoration: none;
    font-size: var(--font-size-md);
    /* e.g., 16px */
}

.result-item a:hover {
    text-decoration: underline;
}

.result-timestamp {
    font-size: var(--font-size-sm);
    /* e.g., 14px */
    color: var(--text-secondary);
    margin-top: var(--spacing-xs);
    /* e.g., 5px */
}

/* Update color variables if necessary */
.light-complementary,
.dark-mode {
    --input-background: #f0f0f0;
    /* Adjust as needed */
    --link-color: var(--accent-color);
    --text-secondary: #888888;
    /* Adjust as needed */
}

/* Adjust spacing variables if not already defined */
:root {
    --spacing-xs: 5px;
    --spacing-sm: 10px;
    --spacing-md: 15px;
    --spacing-lg: 20px;
    --font-size-sm: 14px;
    --font-size-md: 16px;
    --border-radius-5: 5px;
}


===== app/static/css/main.css =====

/* main.css */

@import 'chat.css';
@import 'color-scheme-selector.css';
@import 'colors.css';
@import 'drag-drop.css';
@import 'layout.css';
@import 'macro-script.css';
@import 'messages.css';
@import 'responsive.css';
@import 'sidebar.css';
@import 'utilities.css';

body {
    font-family: 'Roboto', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    margin: 0;
    padding: 0;
    background-color: var(--background-dark);
    color: var(--text-primary);
    -webkit-font-smoothing: antialiased;
}

/* Optional: Transition for Theme Changes */
body {
    transition: background-color 0.3s ease, color 0.3s ease;
}


===== app/static/css/messages.css =====

/* Chat Bubbles for Output and User Input */
.output-bubble,
.user-input-bubble {
    width: 95%;
    max-width: 100%;
    padding: var(--spacing-md);
    /* e.g., 15px */
    border-radius: var(--border-radius-15);
    word-wrap: break-word;
    background: var(--bubble-background);
    display: flex;
    align-items: flex-start;
    flex-direction: column;
    margin-bottom: var(--spacing-md);
    /* e.g., 15px */
    position: relative;
    overflow: hidden;
    /* Changed from visible to hidden for better layout control */
    transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
    /* Added specific transitions for relevant properties */
}

.output-bubble {
    align-self: flex-start;
    background-color: var(--output-background);
    color: var(--text-primary);
    /* Reflect: Consistent color for output bubbles to differentiate from user inputs */
}

.user-input-bubble {
    align-self: flex-end;
    background-color: var(--user-background);
    color: var(--text-primary);
    /* Reflect: Highlight user messages with accent color for distinction */
}

.output-bubble::before,
.user-input-bubble::before {
    content: none;
    /* Reflect: Removed pseudo-elements for cleaner design */
}

/* Define bubble backgrounds in color schemes */
.light-complementary {
    --bubble-background: var(--background-light);
    --output-background: var(--output-bubble-background-light);
    --user-background: var(--accent-color);
}

.dark-mode {
    --bubble-background: var(--background-dark);
    --output-background: var(--output-bubble-background-dark);
    --user-background: var(--accent-color);
}

/* Example definitions for output and user bubble backgrounds */
.light-complementary {
    --output-bubble-background-light: var(--color-white-10);
    --user-background: var(--accent-color);
}

.dark-mode {
    --output-bubble-background-dark: var(--color-white-10);
    --user-background: var(--accent-color);
}


===== app/static/css/responsive.css =====

@media (max-width: 1024px) {
    .container {
        flex-direction: column;
        padding: 10px;
    }

    .left-column,
    .right-column {
        width: 100%;
        padding: 15px;
        max-height: 50vh;
    }

    .sidebar {
        position: relative;
        width: 100%;
        order: 2;
        margin-top: 20px;
        height: auto;
        z-index: 5;
    }

    .sidebar.collapsed+.left-column {
        margin-left: 0;
        width: 100%;
    }

    .macro-script-window {
        margin-left: 0;
        z-index: 1;
    }
}

@media (max-width: 768px) {
    .container {
        padding: 5px;
    }

    .left-column,
    .right-column {
        padding: 10px;
        width: 100%;
        max-height: 50vh;
    }

    .macro-script-container,
    #upload-btn,
    #macro-preview-container {
        width: 95%;
        margin: 10px auto;
    }

    #drop-zone,
    textarea#macro_script {
        width: 95%;
        max-width: 100%;
        padding: 10px;
    }

    .sidebar {
        width: 15%;
        height: 100%;
        transition: width 0.3s ease, transform 0.3s ease;
        overflow-y: auto;
        z-index: 10;
    }
}

@media (max-width: 480px) {
    .container {
        flex-direction: column;
        padding: 10px;
    }

    .sidebar,
    .macro-script-window {
        width: 100%;
        margin: 0;
    }

    #execution-results {
        max-height: 150px;
        overflow-y: auto;
    }
}


===== app/static/css/sidebar.css =====

/* Sidebar Styles */
.sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    width: 12.5%;
    background-color: rgba(255, 255, 255, 0.05);
    border-right: 1px solid var(--border-color);
    box-shadow: 0 0 10px var(--glow-color);
    transition: width 0.3s ease, transform 0.3s ease;
    overflow-y: auto;
    z-index: 1000;
    /* Reflect: Sidebar width and transitions should not conflict with main content */
}

.sidebar.collapsed {
    width: 2.5%;
    /* Reflect: Collapsed state for sidebar to maximize content area */
}

.sidebar-toggle {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 30px;
    height: 30px;
    background-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.3s ease;
    /* Reflect: Toggle button for sidebar responsiveness */
}

.sidebar-toggle:hover {
    background-color: var(--color-white-10);
    /* Reflect: Visual feedback on hover for better user interaction */
}

.sidebar-toggle img {
    width: 20px;
    height: 15px;
    transition: transform 0.3s ease;
    /* Reflect: Animation for clear indication of state changes */
}

.sidebar.collapsed .sidebar-toggle img {
    transform: rotate(180deg);
    /* Reflect: Rotate icon for visual clarity on sidebar state */
}

.sidebar-content {
    padding: 20px;
    padding-top: 50px;
    /* Reflect: Adequate padding for readability and aesthetic */
}

#image-preview-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    /* Reflect: Consistent spacing for image previews */
}

.image-preview {
    position: relative;
    width: 100%;
    padding-top: 100%;
    /* 1:1 Aspect Ratio */
    border: 1px solid var(--border-color);
    border-radius: 5px;
    overflow: hidden;
    transition: all 0.3s ease;
    /* Reflect: Cohesive design with subtle transitions */
}

.image-preview img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    /* Reflect: Proper image fitting for preview elements */
}

.image-preview:hover {
    box-shadow: 0 0 15px var(--glow-color);
    /* Reflect: Highlight images on hover to engage users */
}

.image-preview .file-name {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.7);
    color: var(--text-primary);
    padding: 5px;
    font-size: 12px;
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    /* Reflect: Legible filenames with clear text wrapping */
}

.image-preview .remove-image {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: rgba(0, 0, 0, 0.7);
    color: var(--text-primary);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 12px;
    z-index: 1000;
    /* Reflect: Interactive remove button with clear functionality */
}

.sidebar.collapsed .sidebar-content,
.sidebar.collapsed .image-preview .file-name {
    display: none;
    /* Reflect: Minimize content in collapsed state for focus on main view */
}

/* Responsive Adjustments for Sidebar */
@media (max-width: 1024px) {
    .sidebar {
        width: 8%;
    }

    .sidebar.collapsed {
        width: 3%;
    }
}

@media (max-width: 768px) {
    .sidebar {
        width: 15%;
    }

    .sidebar.collapsed {
        width: 5%;
    }

    .sidebar-toggle {
        width: 25px;
        height: 25px;
    }
}


===== app/static/css/utilities.css =====

/* General Utility Classes */

/* Flex Utilities */
.flex {
    display: flex;
}

.flex-column {
    flex-direction: column;
}

.flex-center {
    justify-content: center;
    align-items: center;
}

.flex-start {
    justify-content: flex-start;
    align-items: flex-start;
}

.flex-space-between {
    justify-content: space-between;
}

/* Grid Utilities */
.grid {
    display: grid;
}

.grid-auto {
    grid-auto-flow: row;
}

.grid-gap {
    gap: 10px;
}

/* Width and Height Utilities */
.w-100 {
    width: 100%;
}

.max-w-100 {
    max-width: 100%;
}

.h-100 {
    height: 100%;
}

.max-h-100 {
    max-height: 100%;
}

/* Margin and Padding Utilities */
.m-0 {
    margin: 0;
}

.mb-15 {
    margin-bottom: 15px;
}

.mt-15 {
    margin-top: 15px;
}

.p-10 {
    padding: 10px;
}

.p-15 {
    padding: 15px;
}

.pb-20 {
    padding-bottom: 20px;
}

.pt-20 {
    padding-top: 20px;
}

/* Box-Sizing */
.box-sizing-border {
    box-sizing: border-box;
}

/* Border Radius */
.border-radius-5 {
    border-radius: 5px;
}

.border-radius-10 {
    border-radius: 10px;
}

.border-radius-15 {
    border-radius: 15px;
}

/* Text Alignment */
.text-center {
    text-align: center;
}

/* Transition Effects */
.transition-ease {
    transition: all 0.3s ease;
}

.transition-bg-color {
    transition: background-color 0.3s ease;
}

.transition-box-shadow {
    transition: box-shadow 0.3s ease;
}

/* Shadow and Glow Effects */
.box-shadow {
    box-shadow: 0 0 10px var(--shadow-color);
}

.glow {
    box-shadow: 0 0 10px var(--glowing-section);
}

.glow-strong {
    box-shadow: 0 0 15px var(--accent-color);
}

/* Hover Effects */
.hover-shadow {
    transition: box-shadow 0.2s ease;
}

.hover-bg-highlight:hover {
    background-color: var(--highlight);
}

/* Visibility */
.visible {
    visibility: visible;
}

.hidden {
    visibility: hidden;
}

/* Overflow */
.overflow-hidden {
    overflow: hidden;
}

.overflow-auto {
    overflow-y: auto;
}

/* Z-Index */
.z-index-0 {
    z-index: 0;
}

.z-index-1 {
    z-index: 1;
}

.z-index-10 {
    z-index: 10;
}

.z-index-1000 {
    z-index: 1000;
}

/* Custom Utility Classes for Specific Needs */

/* Used for no scrolling where not desired */
.no-scroll {
    overflow: hidden;
}

/* Enables auto-scrolling within elements */
.auto-scroll {
    overflow-y: auto;
}

/* Divider for sections */
.section-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 20px 0;
    /* Reflect: Subtle separation between sections */
}

/* Button Styling */
.button-primary {
    cursor: pointer;
    border: none;
    background-color: var(--accent-color);
    color: var(--text-primary);
    padding: 10px 20px;
    border-radius: 5px;
    transition: background-color 0.3s ease, transform 0.1s ease;
}

.button-primary:hover {
    background-color: var(--secondary);
    transform: translateY(-2px);
}

.button-primary:active {
    transform: translateY(0);
}

/* Specific Transition Rules */
.specific-transition {
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

.image-transition {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* Loading Indicator Styles */
.loading-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: none;
    z-index: 1001;
}

.loading-indicator.visible {
    display: block;
}


===== app/static/js/apiCalls.js =====

/**
 * @file apiCalls.js
 * @description Manages API calls for the Atlas application.
 *
 * This module provides functions for generating macros, improving prompts,
 * and handling streaming responses from the server.
 */

import { ROUTES } from './routes.js';

const API_BASE_URL = 'http://127.0.0.1:8000';

/**
 * Generates a macro using EventSource and handles streamed responses.
 *
 * @function generateMacro
 * @param {string} input - The prompt input for macro generation.
 * @param {boolean} improvePrompt - Whether the prompt was improved.
 * @returns {EventSource} - The EventSource instance.
 */
export function generateMacro(input, improvePrompt = false) {
    const params = new URLSearchParams({
        input: input,
        improve_prompt: improvePrompt.toString(),
    });
    const url = `${API_BASE_URL}${ROUTES.GENERATE_MACRO}?${params.toString()}`;
    return new EventSource(url);
}

/**
 * Initiates prompt improvement and streams the improved prompt back to the user.
 *
 * @function generateImprovedPrompt
 * @param {string} input - The original user input.
 * @returns {EventSource} - The EventSource instance for streaming responses.
 */
export function generateImprovedPrompt(input) {
    const params = new URLSearchParams({
        input: input,
    });
    const url = `${API_BASE_URL}${ROUTES.IMPROVE_PROMPT}?${params.toString()}`;
    return new EventSource(url);
}

/**
 * Handles API errors consistently.
 * @param {Response} response - The fetch Response object.
 * @throws {Error} Throws an error with status and message if the response is not ok.
 */
async function handleApiError(response) {
    if (!response.ok) {
        const errorMessage = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorMessage}`);
    }
}

/**
 * Uploads images and optionally executes a macro.
 * Handles response parsing with clear content type checks.
 *
 * @param {File[]} files - The list of files to upload.
 * @param {boolean} [executeMacro=false] - Whether to execute a macro script.
 * @param {string} [macroScript=''] - The macro script to execute.
 * @returns {Promise<Object|Blob>} The response from the server.
 * @throws {Error} If the upload fails.
 */
export async function uploadImage(files, executeMacro = false, macroScript = '') {
    const formData = new FormData();
    files.forEach((file) => formData.append('files', file));
    formData.append('execute_macro', executeMacro.toString());
    if (executeMacro && macroScript) {
        formData.append('macro_script', macroScript);
    }

    try {
        const response = await fetch(`${API_BASE_URL}${ROUTES.UPLOAD_IMAGE}`, {
            method: 'POST',
            body: formData,
        });

        // Check content type and handle accordingly
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            const data = await response.json();
            return data.results;
        } else if (contentType && contentType.includes('application/zip')) {
            const blob = await response.blob();
            return blob;
        } else {
            console.error('Unexpected response content type:', contentType);
            throw new Error('Unsupported response format received');
        }
    } catch (error) {
        console.error('Error uploading image:', error);
        throw error;
    }
}

/**
 * Fetches a base64 encoded image preview.
 * @param {string} filename - The filename for which to generate a preview.
 * @returns {Promise<string>} The base64-encoded preview image.
 * @throws {Error} If fetching the preview fails.
 */
export async function generateImagePreview(filename) {
    try {
        const response = await fetch(`${API_BASE_URL}/get_image_preview/${filename}`, {
            method: 'GET',
        });

        await handleApiError(response);
        const data = await response.json();
        return data.preview;
    } catch (error) {
        console.error('Error generating image preview:', error);
        throw error;
    }
}

/**
 * Deletes an image and its associated data.
 * @param {string} filename - The filename of the image to delete.
 * @returns {Promise<Object>} The response from the server.
 * @throws {Error} If the deletion fails.
 */
export async function deleteImage(filename) {
    try {
        const response = await fetch(`${API_BASE_URL}${ROUTES.DELETE_IMAGE}${filename}`, {
            method: 'DELETE',
        });

        await handleApiError(response);
        return await response.json();
    } catch (error) {
        console.error('Error deleting image:', error);
        throw error;
    }
}

/**
 * Executes a macro on the provided images.
 * @param {File[]} files - The list of image files.
 * @param {string} macroScript - The macro script to execute.
 * @returns {Promise<Object|Blob>} The response from the server.
 */
export async function executeImageMacro(files, macroScript) {
    return uploadImage(files, true, macroScript);
}


===== app/static/js/chatInterface.js =====

/**
 * @file chatInterface.js
 * @description Manages the chat interface for the Atlas application.
 *
 * This module provides a ChatInterface class that handles user interactions,
 * prompt improvements, and macro generation. It offers a dynamic and responsive
 * interface for real-time communication with the AI.
 *
 * @module chatInterface
 * @requires apiCalls
 * @requires uiUpdates
 * @requires utils
 */

import { generateMacro, generateImprovedPrompt } from './apiCalls.js';
import {
    updateChatMessage,
    scrollChatToBottom,
    updateMacroScript,
    displayErrorMessage,
    displaySuccessMessage,
    showLoadingIndicator,
    hideLoadingIndicator,
    updateInputArea,
} from './uiUpdates.js';
import { adjustTextareaHeight } from './utils.js';

/**
 * @class ChatInterface
 * @description Manages the chat interface and user interactions.
 */
export default class ChatInterface {
    /**
     * @constructor
     * @param {Object} sidebar - The sidebar instance for managing UI updates.
     */
    constructor(sidebar) {
        this.sidebar = sidebar;
        this.userInput = document.getElementById('user-input');
        this.chatForm = document.getElementById('chat-form');
        this.chatSubmitBtn = document.getElementById('chat-submit-btn');
        this.improvePromptCheckbox = document.getElementById('improve-prompt');

        this.currentSection = '';
        this.accumulatedContent = {};
        this.isImprovedPromptGenerated = false;

        // Property to keep track of the conversation index
        this.conversationIndex = 0;

        this.initializeEventListeners();
    }

    /**
     * @method initializeEventListeners
     * @description Sets up event listeners and initializes the chat interface.
     */
    initializeEventListeners() {
        this.userInput.addEventListener('input', () => adjustTextareaHeight(this.userInput));
        this.chatForm.addEventListener('submit', (e) => this.submitChat(e));
        this.chatSubmitBtn.addEventListener('click', (e) => this.submitChat(e));
        this.userInput.addEventListener('keydown', (e) => this.handleEnterKey(e));
    }

    /**
     * @method submitChat
     * @async
     * @description Handles form submission for chat messages.
     * @param {Event} e - The form submit event.
     */
    async submitChat(e) {
        e.preventDefault();
        const userInputValue = this.userInput.value.trim();
        const shouldImprovePrompt = this.improvePromptCheckbox.checked;

        if (!userInputValue) return;

        try {
            if (shouldImprovePrompt && !this.isImprovedPromptGenerated) {
                // User wants to improve the prompt and we haven't done it yet
                showLoadingIndicator();
                await this.handleImprovedPromptStreaming(userInputValue);
                hideLoadingIndicator();
                // Now, the improved prompt is in the input box, and the user can edit it
                // Set isImprovedPromptGenerated to true, so that next time we know we've improved it
                this.isImprovedPromptGenerated = true;
            } else {
                // Proceed with macro generation
                showLoadingIndicator();
                // Increment the conversation index
                this.conversationIndex += 1;

                // Use the conversation index to ensure messages are appended to the bottom
                const userMessageSection = `user-input-${this.conversationIndex}`;
                updateChatMessage('You', userInputValue, userMessageSection);

                await this.handleMacroGeneration(userInputValue, this.isImprovedPromptGenerated);

                displaySuccessMessage('Macro generated successfully.');
                // Reset the flag
                this.isImprovedPromptGenerated = false;
                this.improvePromptCheckbox.checked = false;
                // Clear the input
                this.userInput.value = '';
                adjustTextareaHeight(this.userInput);
            }
        } catch (error) {
            console.error('Error in chat submission:', error);
            displayErrorMessage('An error occurred: ' + error.message);
        } finally {
            hideLoadingIndicator();
        }
    }

    /**
     * @method handleEnterKey
     * @description Handles the Enter key press in the input area.
     * @param {KeyboardEvent} e - The keyboard event.
     */
    handleEnterKey(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.submitChat(e);
        }
    }

    /**
     * @method handleImprovedPromptStreaming
     * @async
     * @description Handles the streaming of improved prompts.
     * @param {string} input - The original user input.
     */
    async handleImprovedPromptStreaming(input) {
        this.accumulatedContent = { improved_prompt: '' };
        const eventSource = generateImprovedPrompt(input);

        return new Promise((resolve, reject) => {
            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.event === 'improved_prompt_chunk') {
                    this.accumulatedContent.improved_prompt += data.data.chunk;
                    updateInputArea(this.accumulatedContent.improved_prompt);
                } else if (data.event === 'improved_prompt_complete') {
                    eventSource.close();
                    this.isImprovedPromptGenerated = true;
                    this.improvePromptCheckbox.checked = false;
                    // The improved prompt is now in the input area
                    // The user can edit it and decide whether to submit
                    resolve();
                }
            };

            eventSource.onerror = (error) => {
                console.error('Error in EventSource:', error);
                eventSource.close();
                displayErrorMessage('Failed to improve prompt. Please try again or proceed with the original input.');
                this.isImprovedPromptGenerated = false;
                this.improvePromptCheckbox.checked = false;
                reject(error);
            };
        });
    }

    /**
     * @method handleMacroGeneration
     * @async
     * @description Initiates macro generation using the provided prompt.
     * @param {string} prompt - The final prompt for macro generation.
     * @param {boolean} improvedPrompt - Whether the prompt was improved.
     */
    async handleMacroGeneration(prompt, improvedPrompt) {
        // Use the current conversation index
        const interactionId = this.conversationIndex;

        // Update the system message with a unique section
        const systemMessageSection = `system-${interactionId}`;
        updateChatMessage('System', 'Generating macro...', systemMessageSection);

        this.currentSection = '';
        this.accumulatedContent = {};

        console.log('Sending prompt to generateMacro:', prompt);

        const eventSource = generateMacro(prompt, improvedPrompt);

        return new Promise((resolve, reject) => {
            eventSource.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    await this.handleStreamedContent(data, interactionId);

                    if (data.event === 'complete') {
                        eventSource.close();
                        resolve();
                    }
                } catch (error) {
                    console.error('Error processing message:', error);
                    eventSource.close();
                    reject(error);
                }
            };

            eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                eventSource.close();
                displayErrorMessage('An error occurred during macro generation.');
                reject(new Error('An error occurred during macro generation.'));
            };
        });
    }

    /**
     * @method handleStreamedContent
     * @async
     * @description Processes streamed content based on the event type and updates the UI accordingly.
     * @param {Object} data - The data object containing event and content details.
     * @param {number} interactionId - The unique interaction ID for this conversation.
     */
    async handleStreamedContent(data, interactionId) {
        switch (data.event) {
            case 'section_change':
                this.handleSectionChange(data.data, interactionId);
                break;
            case 'message':
                await this.updateStreamingContent(data.data.section, data.data.content, interactionId);
                break;
            case 'complete':
                this.finalizeSectionContent(interactionId);
                const systemMessageSection = `system-${interactionId}`;
                updateChatMessage('System', 'Macro generation complete.', systemMessageSection);
                break;
            case 'error':
                displayErrorMessage(data.data.error);
                break;
            default:
                console.warn('Unknown event type:', data.event);
        }
        scrollChatToBottom();
    }

    /**
     * @method handleSectionChange
     * @description Handles section changes in the streamed content.
     * @param {Object} data - The section change data.
     * @param {number} interactionId - The unique interaction ID for this conversation.
     */
    handleSectionChange(data, interactionId) {
        this.finalizeSectionContent(interactionId);
        this.currentSection = data.section;
        this.accumulatedContent[this.currentSection] = '';

        // Update the current section with the interaction ID to ensure uniqueness
        this.currentSectionWithId = `${this.currentSection}-${interactionId}`;
    }

    /**
     * @method updateStreamingContent
     * @async
     * @description Updates the content within a section, handling accumulation and real-time updates.
     * @param {string} section - The section type being updated.
     * @param {string} content - The new content to add to the section.
     * @param {number} interactionId - The unique interaction ID for this conversation.
     */
    async updateStreamingContent(section, content, interactionId) {
        if (!this.accumulatedContent[section]) {
            this.accumulatedContent[section] = '';
        }

        this.accumulatedContent[section] += content;
        const cleanedContent = this.cleanContent(this.accumulatedContent[section], section);

        const sectionWithId = `${section}-${interactionId}`;

        if (section === 'macro_script') {
            updateMacroScript(cleanedContent, true, sectionWithId);
        } else if (section !== 'improved_prompt') {
            updateChatMessage('Atlas', cleanedContent, sectionWithId, true);
        }
    }

    /**
     * @method cleanContent
     * @description Cleans the content by removing specific tags.
     * @param {string} content - The raw content.
     * @param {string} section - The section type.
     * @returns {string} The cleaned content.
     */
    cleanContent(content, section) {
        let cleanContent = content.replace(/\[DESCRIPTION\]|\[EXPLANATION\]/gi, '').trim();
        if (section === 'macro_script') {
            const firstCodeIndex = cleanContent.indexOf('//');
            cleanContent = firstCodeIndex !== -1 ? cleanContent.slice(firstCodeIndex) : cleanContent;
        }
        return cleanContent;
    }

    /**
     * @method finalizeSectionContent
     * @description Finalizes content for the current section, ensuring no incomplete data remains.
     * @param {number} interactionId - The unique interaction ID for this conversation.
     */
    finalizeSectionContent(interactionId) {
        if (this.currentSection && this.accumulatedContent[this.currentSection]) {
            const cleanedContent = this.cleanContent(this.accumulatedContent[this.currentSection], this.currentSection);

            const sectionWithId = `${this.currentSection}-${interactionId}`;

            if (this.currentSection === 'macro_script') {
                updateMacroScript(cleanedContent, false, sectionWithId);
            } else {
                updateChatMessage('Atlas', cleanedContent, sectionWithId, false);
            }
        }
    }
}


===== app/static/js/colorSchemeSwitcher.js =====

/**
 * @file colorSchemeSwitcher.js
 * @description Manages the color scheme switching functionality for the Atlas application.
 *
 * This module provides functions to initialize and handle color scheme changes,
 * persisting the user's preference across sessions.
 *
 * @module colorSchemeSwitcher
 */

/**
 * Initializes the color scheme switching functionality.
 */
export function initializeColorScheme() {
    const schemeSelect = document.getElementById('color-scheme-select');
    if (!schemeSelect) {
        console.warn('Color scheme select element not found.');
        return;
    }

    schemeSelect.addEventListener('change', function () {
        const selectedScheme = this.value;
        applyColorScheme(selectedScheme);
    });

    // Load previously selected scheme from local storage on page load
    const savedScheme = localStorage.getItem('selectedColorScheme') || 'default-scheme';
    applyColorScheme(savedScheme);
    schemeSelect.value = savedScheme;
}

/**
 * Applies the selected color scheme to the document body.
 * @param {string} scheme - The selected color scheme.
 */
function applyColorScheme(scheme) {
    // Clears previous scheme classes to avoid conflicts
    document.body.className = '';

    // Applies the selected scheme
    document.body.classList.add(scheme);

    // Persist the user's choice in local storage
    localStorage.setItem('selectedColorScheme', scheme);
}


===== app/static/js/eventListeners.js =====

/**
 * @file eventListeners.js
 * @description Sets up event listeners for the Atlas application.
 *
 * This module provides a function to initialize all event listeners,
 * ensuring that elements are properly referenced and handlers are correctly bound.
 *
 * @module eventListeners
 */

/**
 * Sets up event listeners for the application.
 * @param {Sidebar} sidebar - The sidebar instance.
 * @param {FileHandler} fileHandling - The file handling instance.
 * @param {ChatInterface} chatInterface - The chat interface instance.
 * @param {MacroScriptInterface} macroScriptInterface - The macro script interface instance.
 */
export function setupEventListeners(sidebar, fileHandling, chatInterface, macroScriptInterface) {
    // Helper function to safely add event listeners
    function addListener(id, event, handler) {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener(event, handler);
        } else {
            console.warn(`Element with ID '${id}' not found.`);
        }
    }

    // Ensure the DOM is fully loaded before setting up event listeners
    document.addEventListener('DOMContentLoaded', () => {
        // Chat form submission
        addListener('chat-form', 'submit', (e) => chatInterface.submitChat(e));

        // Image upload form submission
        addListener('image-upload-form', 'submit', (e) => macroScriptInterface.submitImageUpload(e));

        // Attach buttons
        addListener('attach-btn', 'click', () => document.getElementById('chat-file-input')?.click());
        addListener('macro-attach-btn', 'click', () => document.getElementById('images')?.click());

        // File inputs change events
        addListener('chat-file-input', 'change', function () {
            fileHandling.handleFiles(this.files, 'chat');
        });

        addListener('images', 'change', function () {
            fileHandling.handleFiles(this.files, 'macro');
        });

        // Drop zone events
        const dropZone = document.getElementById('drop-zone');
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                fileHandling.handleFiles(e.dataTransfer.files, 'macro');
            });

            dropZone.addEventListener('click', () => document.getElementById('images')?.click());
        } else {
            console.warn('Drop zone element not found.');
        }
    });
}


===== app/static/js/fileHandling.js =====

/**
 * @file fileHandling.js
 * @description Manages file handling operations for the Atlas application.
 *
 * This module provides a FileHandler class that handles file uploads,
 * drag-and-drop functionality, and interaction with the sidebar for
 * displaying file previews.
 *
 * @module fileHandling
 * @requires apiCalls
 * @requires uiUpdates
 */

import { uploadImage } from './apiCalls.js';
import { displayErrorMessage, displaySuccessMessage } from './uiUpdates.js';

/**
 * @class FileHandler
 * @description Manages file handling operations and UI interactions for file uploads.
 */
export class FileHandler {
    /**
     * @constructor
     * @param {Object} sidebar - An object representing the sidebar module with methods to add and remove image previews.
     */
    constructor(sidebar) {
        this.sidebar = sidebar;
        this.dropZone = document.getElementById('drop-zone');
        this.macroFileInput = document.getElementById('images');
        this.chatFileInput = document.getElementById('chat-file-input');
        this.chatAttachBtn = document.getElementById('attach-btn');
        this.macroScriptInput = document.getElementById('macro_script');
        this.uploadBtn = document.getElementById('upload-btn');

        this.microscopySupportedExtensions = ['czi', 'lif', 'nd2', 'oib', 'oif', 'ome.tiff', 'ome.tif'];

        // New property to keep track of the processing runs
        this.processingRunCounter = 0;

        // Element to display download links
        this.resultsContainer = document.getElementById('results-container');

        this.initializeEventListeners();
    }

    /**
     * @method initializeEventListeners
     * @description Sets up event listeners for various file handling interactions.
     */
    initializeEventListeners() {
        this.uploadBtn.addEventListener('click', this.handleUploadButtonClick.bind(this));
        this.dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
        this.dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.dropZone.addEventListener('drop', this.handleDrop.bind(this));
        this.dropZone.addEventListener('click', () => this.macroFileInput.click());
        this.macroFileInput.addEventListener('change', (event) => this.handleFiles(event.target.files, 'macro'));
        this.chatAttachBtn.addEventListener('click', () => this.chatFileInput.click());
        this.chatFileInput.addEventListener('change', (event) => this.handleFiles(event.target.files, 'chat'));
    }

    /**
     * @method handleUploadButtonClick
     * @description Handles the click event for the upload button.
     * @param {Event} event - The click event triggered by the upload button.
     */
    async handleUploadButtonClick(event) {
        event.preventDefault();
        const files = this.sidebar.getAllFiles('macro');
        const macroScript = this.macroScriptInput.value;

        if (!files.length) {
            displayErrorMessage('Please select at least one image file to process.');
            return;
        }

        if (!macroScript.trim()) {
            displayErrorMessage('Please provide a macro script to execute.');
            return;
        }

        await this.handleFiles(files, 'macro', true, macroScript);
    }

    /**
     * @method handleFiles
     * @description Processes uploaded files based on the context.
     * @param {FileList|File[]} fileList - The list of files to be processed.
     * @param {string} context - The context in which the files are being processed ('upload', 'chat', or 'macro').
     * @param {boolean} executeMacro - Whether a macro should be executed on the uploaded files.
     * @param {string} macroScript - The macro script to execute if applicable.
     */
    async handleFiles(fileList, context, executeMacro = false, macroScript = '') {
        const files = Array.isArray(fileList) ? fileList : Array.from(fileList);

        if (files.length === 0) {
            displayErrorMessage('No files selected for processing.');
            return;
        }

        // Filter valid files
        const validFiles = files.filter(file => this.isValidFile(file));
        const invalidFiles = files.filter(file => !this.isValidFile(file));

        if (invalidFiles.length > 0) {
            invalidFiles.forEach(file => {
                displayErrorMessage(`${file.name} is not a supported image format`);
            });
        }

        if (validFiles.length === 0) {
            displayErrorMessage('No valid files to process.');
            return;
        }

        try {
            const response = await this.uploadFiles(validFiles, executeMacro, macroScript);
            this.processUploadResponse(response, validFiles, context, executeMacro);
        } catch (error) {
            console.error('Error processing files:', error);
            displayErrorMessage(`Error processing files: ${error.message}`);
        }

        // Update the file input to include all current files
        this.updateFileInput(context);
    }

    /**
     * @method isValidFile
     * @description Validates whether a file is a supported format.
     * @param {File} file - The file to validate.
     * @returns {boolean} - True if the file is valid, false otherwise.
     */
    isValidFile(file) {
        const fileExtension = file.name.split('.').pop().toLowerCase();
        return file.type.startsWith('image/') || this.microscopySupportedExtensions.includes(fileExtension);
    }

    /**
     * @method uploadFiles
     * @description Uploads files to the server and handles the response.
     * @param {File[]} files - Array of files to be uploaded.
     * @param {boolean} executeMacro - Indicates whether to execute a macro script.
     * @param {string} macroScript - The macro script to be executed.
     * @returns {Promise<Object>} - The processed results from the server.
     * @throws {Error} - Throws an error if the upload fails or the response is invalid.
     */
    async uploadFiles(files, executeMacro = false, macroScript = '') {
        try {
            const response = await uploadImage(files, executeMacro, macroScript);

            if (response instanceof Blob || Array.isArray(response)) {
                return response;
            } else {
                throw new Error('Unexpected response format from server');
            }
        } catch (error) {
            throw error;
        }
    }

    /**
     * @method processUploadResponse
     * @description Processes the server response after file upload.
     * @param {Blob|Object[]} response - The server response to process.
     * @param {File[]} files - The original files that were uploaded.
     * @param {string} context - The context of the upload ('upload', 'chat', or 'macro').
     * @param {boolean} executeMacro - Whether a macro was executed.
     */
    processUploadResponse(response, files, context, executeMacro) {
        if (executeMacro) {
            if (response instanceof Blob) {
                this.processingRunCounter += 1;

                // Create a download link for the results
                const zipUrl = URL.createObjectURL(response);
                const downloadLink = document.createElement('a');
                downloadLink.href = zipUrl;
                downloadLink.download = `results_${this.processingRunCounter}.zip`;
                downloadLink.textContent = `Download Results ${this.processingRunCounter}`;

                // Append the download link to the results container
                if (!this.resultsContainer) {
                    this.resultsContainer = document.createElement('div');
                    this.resultsContainer.id = 'results-container';
                    // Place the results container below the execute button
                    this.uploadBtn.insertAdjacentElement('afterend', this.resultsContainer);
                }
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.appendChild(downloadLink);

                // Optionally, add a timestamp
                const timestamp = new Date().toLocaleString();
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'result-timestamp';
                timestampDiv.textContent = `Generated on: ${timestamp}`;
                resultItem.appendChild(timestampDiv);

                this.resultsContainer.appendChild(resultItem);

                displaySuccessMessage(`Macro executed successfully. Results ${this.processingRunCounter} available for download.`);
            } else {
                throw new Error('Unexpected response format from server');
            }
        } else {
            if (Array.isArray(response)) {
                response.forEach((result, index) => {
                    const file = files[index];
                    this.sidebar.addImagePreview(file, result.preview, context);
                });
                displaySuccessMessage('Images uploaded successfully.');
            } else {
                throw new Error('Unexpected response format from server');
            }
        }
    }

    /**
     * @method updateFileInput
     * @description Updates the file input element to reflect the current state of accumulated previews.
     * @param {string} context - The context for the file input ('upload', 'chat', 'macro').
     */
    updateFileInput(context) {
        const targetInput = context === 'chat' ? this.chatFileInput : this.macroFileInput;
        const allFiles = this.sidebar.getAllFiles(context);

        const dataTransfer = new DataTransfer();
        allFiles.forEach(file => {
            dataTransfer.items.add(file);
        });

        targetInput.files = dataTransfer.files;
    }

    /**
     * @method handleDragOver
     * @description Handles drag-over event for the drop zone.
     * @param {DragEvent} e - The drag event.
     */
    handleDragOver(e) {
        e.preventDefault();
        this.dropZone.classList.add('drag-over');
    }

    /**
     * @method handleDragLeave
     * @description Handles drag-leave event for the drop zone.
     */
    handleDragLeave() {
        this.dropZone.classList.remove('drag-over');
    }

    /**
     * @method handleDrop
     * @description Handles the drop event for the drop zone.
     * @param {DragEvent} e - The drop event.
     */
    handleDrop(e) {
        e.preventDefault();
        this.dropZone.classList.remove('drag-over');
        this.handleFiles(e.dataTransfer.files, 'macro');
    }
}


===== app/static/js/macroScriptInterface.js =====

/**
 * @file macroScriptInterface.js
 * @description Manages the macro script interface for the Atlas application.
 *
 * This module provides a MacroScriptInterface class that handles macro script
 * submissions, image uploads associated with macros, and result processing.
 *
 * @module macroScriptInterface
 * @requires apiCalls
 * @requires uiUpdates
 */

import { uploadImage } from './apiCalls.js';
import {
    displaySuccessMessage,
    displayErrorMessage,
    displayResults,
    showLoadingIndicator,
    hideLoadingIndicator,
} from './uiUpdates.js';

/**
 * @class MacroScriptInterface
 * @description Manages the macro script interface and associated image uploads.
 */
export class MacroScriptInterface {
    /**
     * @constructor
     * @param {Sidebar} sidebar - The sidebar instance for managing image previews.
     */
    constructor(sidebar) {
        this.sidebar = sidebar;
        this.macroScriptTextarea = document.getElementById('macro_script');
        this.uploadBtn = document.getElementById('upload-btn');

        this.initializeEventListeners();
    }

    /**
     * @method initializeEventListeners
     * @description Sets up event listeners for the macro script interface.
     */
    initializeEventListeners() {
        this.uploadBtn.addEventListener('click', (e) => this.submitImageUpload(e));
    }

    /**
     * @method stripFirstLine
     * @description Removes the first line of the script if it starts with 'ijm' or 'javascript'.
     * @param {string} script - The original macro script.
     * @returns {string} The script with the first line potentially removed.
     */
    stripFirstLine(script) {
        const lines = script.split('\n');
        const firstLine = lines[0].trim().toLowerCase();
        if (firstLine.startsWith('ijm') || firstLine.startsWith('javascript')) {
            return lines.slice(1).join('\n');
        }
        return script;
    }

    /**
     * @method submitImageUpload
     * @async
     * @description Handles the submission of images with associated macro scripts.
     * @param {Event} e - The event object from the submit button click.
     */
    async submitImageUpload(e) {
        e.preventDefault();

        // Get all files from the sidebar previews for the 'macro' context
        const previews = this.sidebar.getAllPreviews('macro');
        if (previews.length === 0) {
            displayErrorMessage('No images selected for processing.');
            return;
        }
        const files = previews.map(preview => preview.file);

        const macroScript = this.macroScriptTextarea.value.trim();
        if (!macroScript) {
            displayErrorMessage('Macro script cannot be empty.');
            return;
        }

        const strippedMacro = this.stripFirstLine(macroScript);

        try {
            showLoadingIndicator();

            const response = await uploadImage(files, true, strippedMacro);
            await this.processResponse(response);
        } catch (error) {
            console.error('Error:', error);
            displayErrorMessage('An error occurred while communicating with the server.');
        } finally {
            hideLoadingIndicator();
        }
    }

    /**
     * @method processResponse
     * @async
     * @description Processes the server response after image upload and macro execution.
     * @param {Object|Blob} response - The response from the server.
     */
    async processResponse(response) {
        if (response instanceof Blob) {
            await this.handleZipResponse(response);
        } else if (typeof response === 'object') {
            await this.handleJsonResponse(response);
        } else {
            console.error('Unexpected response type:', typeof response);
            displayErrorMessage('Received an unexpected response from the server.');
        }
    }

    /**
     * @method handleZipResponse
     * @async
     * @description Handles a ZIP file response from the server.
     * @param {Blob} blob - The Blob object containing the ZIP file.
     */
    async handleZipResponse(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'results.zip';
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
        displaySuccessMessage('Results downloaded successfully.');
    }

    /**
     * @method handleJsonResponse
     * @async
     * @description Handles a JSON response from the server.
     * @param {Object} data - The JSON data from the server.
     */
    async handleJsonResponse(data) {
        if (data.error) {
            displayErrorMessage(data.error);
        } else {
            displayResults(data);
            displaySuccessMessage('Macro executed successfully.');
        }
    }
}


===== app/static/js/main.js =====

/**
 * @file main.js
 * @description Main entry point for the Atlas application.
 *
 * This module initializes all the major components of the application,
 * sets up event listeners, and manages the overall application state.
 *
 * @module main
 */

import { Sidebar } from './sidebar.js';
import { FileHandler } from './fileHandling.js';
import ChatInterface from './chatInterface.js';
import { MacroScriptInterface } from './macroScriptInterface.js';
import { setupEventListeners } from './eventListeners.js';
import { initializeColorScheme } from './colorSchemeSwitcher.js';

/**
 * @class AtlasApp
 * @description Main application class that initializes and manages all components.
 */
class AtlasApp {
    /**
     * @constructor
     * @description Initializes the Atlas application.
     */
    constructor() {
        this.sidebar = null;
        this.fileHandler = null;
        this.chatInterface = null;
        this.macroScriptInterface = null;
    }

    /**
     * @method initialize
     * @description Initializes all components of the application.
     */
    initialize() {
        this.sidebar = new Sidebar();
        this.fileHandler = new FileHandler(this.sidebar);
        this.chatInterface = new ChatInterface(this.sidebar);
        this.macroScriptInterface = new MacroScriptInterface(this.sidebar);

        setupEventListeners(this.sidebar, this.fileHandler, this.chatInterface, this.macroScriptInterface);
        initializeColorScheme();
    }
}

// Initialize the application when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    const app = new AtlasApp();
    app.initialize();
});


===== app/static/js/routes.js =====

// app/static/js/routes.js
export const ROUTES = {
    UPLOAD_IMAGE: "/upload-image/",
    DELETE_IMAGE: "/delete-image/",
    GENERATE_MACRO: "/stream-generate-macro/",
    IMPROVE_PROMPT: "/stream-improve-prompt/",
};


===== app/static/js/sidebar.js =====

/**
 * @file sidebar.js
 * @description Manages the sidebar functionality for the Atlas application.
 *
 * This module provides a Sidebar class that handles image preview management,
 * sidebar toggling, and interaction with the backend for image deletion.
 *
 * @module sidebar
 * @requires apiCalls
 */

import { deleteImage } from './apiCalls.js';

/**
 * @class Sidebar
 * @description Manages sidebar functionality and image preview handling.
 */
export class Sidebar {
    /**
     * @constructor
     * @description Initializes the Sidebar instance and sets up event listeners.
     */
    constructor() {
        this.sidebar = document.getElementById('sidebar');
        this.sidebarToggle = document.getElementById('sidebar-toggle');
        this.imagePreviewContainer = document.getElementById('image-preview-container');

        this.initializeEventListeners();
    }

    /**
     * @method initializeEventListeners
     * @description Sets up event listeners for sidebar functionality.
     */
    initializeEventListeners() {
        this.sidebarToggle.addEventListener('click', this.toggleSidebar.bind(this));
    }

    /**
     * @method toggleSidebar
     * @description Toggles the sidebar's collapsed state.
     */
    toggleSidebar() {
        this.sidebar.classList.toggle('collapsed');
        document.body.classList.toggle('sidebar-expanded');
    }

    /**
     * @method addImagePreview
     * @description Adds an image preview to the sidebar.
     * @param {File} file - The file to preview.
     * @param {string} previewUrl - The URL of the preview image.
     * @param {string} context - The context of the preview ('upload', 'chat', 'macro').
     */
    addImagePreview(file, previewUrl, context) {
        const previewElement = document.createElement('div');
        previewElement.className = 'image-preview';
        previewElement.innerHTML = `
            <img src="${previewUrl}" alt="${file.name}">
            <div class="file-name">${file.name}</div>
            <button class="remove-image" data-context="${context}">×</button>
        `;
        previewElement.file = file;
        previewElement.dataset.context = context;
        this.imagePreviewContainer.appendChild(previewElement);

        const removeBtn = previewElement.querySelector('.remove-image');
        removeBtn.addEventListener('click', () => this.removeImagePreview(file, context));
    }

    /**
     * @method removeImagePreview
     * @description Removes an image preview from the sidebar and deletes it from the backend.
     * @param {File} file - The file to remove.
     * @param {string} context - The context of the preview ('upload', 'chat', 'macro').
     */
    async removeImagePreview(file, context) {
        // Remove the preview element
        const previews = this.imagePreviewContainer.querySelectorAll('.image-preview');
        previews.forEach(preview => {
            if (preview.file && preview.file.name === file.name && preview.file.size === file.size) {
                preview.remove();
            }
        });

        // Update the file input
        const fileInput = context === 'chat' ? document.getElementById('chat-file-input') : document.getElementById('images');
        const dt = new DataTransfer();

        Array.from(fileInput.files).forEach(f => {
            if (!(f.name === file.name && f.size === file.size)) {
                dt.items.add(f);
            }
        });

        fileInput.files = dt.files;

        // Delete the image from the backend
        const uniqueFilename = file.uniqueFilename || file.name;

        try {
            await deleteImage(uniqueFilename);
        } catch (error) {
            console.error('Error removing image from backend:', error);
        }
    }

    /**
     * @method clearPreviews
     * @description Clears all image previews from the sidebar.
     */
    clearPreviews() {
        this.imagePreviewContainer.innerHTML = '';
    }

    /**
     * @method getAllPreviews
     * @description Gets all image previews for a specific context.
     * @param {string} context - The context to filter previews ('upload', 'chat', 'macro').
     * @returns {Array} An array of preview objects containing file and element information.
     */
    getAllPreviews(context) {
        const previews = [];
        const previewElements = this.imagePreviewContainer.querySelectorAll('.image-preview');
        previewElements.forEach(preview => {
            if (preview.dataset.context === context) {
                const file = preview.file;
                if (file) {
                    previews.push({ file: file, element: preview });
                }
            }
        });
        return previews;
    }
}


===== app/static/js/uiUpdates.js =====

/**
 * @file uiUpdates.js
 * @description Manages UI updates for the Atlas application chat interface.
 *
 * This module provides functions for displaying and updating various types of messages,
 * including chat messages, macro scripts, error messages, and loading indicators.
 * It also handles scrolling, UI element management, and streaming content updates.
 */

/**
 * Creates a new message bubble in the chat log.
 * @param {string} sender - The sender of the message.
 * @param {string} section - The section type of the message.
 * @returns {HTMLElement} The newly created message bubble.
 */
export function createNewMessageBubble(sender, section) {
    const chatLog = document.getElementById('chat-log');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${section.includes('user-input') ? 'user-input-bubble' : 'output-bubble'}`;
    messageDiv.setAttribute('data-section', section);
    messageDiv.innerHTML = `<span>${sender}: </span><div class="message-content"></div>`;
    chatLog.appendChild(messageDiv);
    scrollChatToBottom();
    return messageDiv;
}

/**
 * Updates or creates a chat message in the chat log.
 * @param {string} sender - The sender of the message.
 * @param {string} message - The message content.
 * @param {string} section - The section type of the message.
 * @param {boolean} isStreaming - Whether the content is being streamed.
 */
export function updateChatMessage(sender, message, section, isStreaming = false) {
    const chatLog = document.getElementById('chat-log');
    let messageDiv = chatLog.querySelector(`.chat-message[data-section="${section}"]`);

    if (!messageDiv) {
        messageDiv = createNewMessageBubble(sender, section);
    }

    const contentDiv = messageDiv.querySelector('.message-content');
    contentDiv.textContent = message;

    if (isStreaming) {
        contentDiv.classList.add('streaming-content');
    } else {
        contentDiv.classList.remove('streaming-content');
    }

    scrollChatToBottom();
}

/**
 * Updates or creates the macro script window in the chat log.
 * Applies syntax highlighting and sets up copy and paste buttons.
 * @param {string} script - The macro script content.
 * @param {boolean} isStreaming - Whether the content is being streamed.
 * @param {string} section - The section identifier for the macro script.
 */
export function updateMacroScript(script, isStreaming = false, section = 'macro_script') {
    const chatLog = document.getElementById('chat-log');
    let scriptDiv = chatLog.querySelector(`.macro-script-window[data-section="${section}"]`);

    if (!scriptDiv) {
        scriptDiv = createMacroScriptWindow(section);
        chatLog.appendChild(scriptDiv);
    }

    const codeElement = scriptDiv.querySelector('code');
    codeElement.textContent = script;

    if (typeof hljs !== 'undefined') {
        hljs.highlightElement(codeElement);
    }

    setupMacroScriptButtons(scriptDiv, script);
    scrollChatToBottom();
}

/**
 * Creates the macro script window element and sets up its structure.
 * @param {string} section - The section identifier for the macro script window.
 * @returns {HTMLElement} The created macro script window element.
 */
function createMacroScriptWindow(section) {
    const scriptDiv = document.createElement('div');
    scriptDiv.className = 'macro-script-window';
    scriptDiv.setAttribute('data-section', section);
    scriptDiv.innerHTML = `
        <div class="macro-script-header">Macro Script</div>
        <pre class="macro-script-content"><code class="language-javascript"></code></pre>
        <div class="macro-script-actions">
            <button class="copy-btn">Copy</button>
            <button class="paste-btn">Paste</button>
        </div>
    `;
    return scriptDiv;
}

/**
 * Sets up the copy and paste buttons for the macro script interface.
 * @param {HTMLElement} scriptDiv - The macro script window element.
 * @param {string} script - The macro script content.
 */
function setupMacroScriptButtons(scriptDiv, script) {
    const copyBtn = scriptDiv.querySelector('.copy-btn');
    const pasteBtn = scriptDiv.querySelector('.paste-btn');

    copyBtn.onclick = () => copyToClipboard(script, 'Macro script copied to clipboard.');
    pasteBtn.onclick = () => pasteToMacroEditor(script);
}




/**
 * Copies the given text to clipboard.
 * @param {string} text - The text to copy.
 * @param {string} successMessage - The message to display on successful copy.
 */
function copyToClipboard(text, successMessage) {
    navigator.clipboard.writeText(text).then(() => {
        displaySuccessMessage(successMessage);
    }).catch(err => {
        displayErrorMessage('Failed to copy the macro script.');
        console.error('Error copying to clipboard:', err);
    });
}

/**
 * Pastes the given script into the macro editor textarea.
 * @param {string} script - The script to paste.
 */
function pasteToMacroEditor(script) {
    const macroScriptTextarea = document.getElementById('macro_script');
    if (macroScriptTextarea) {
        macroScriptTextarea.value = script;
        macroScriptTextarea.dispatchEvent(new Event('input'));
        displaySuccessMessage('Macro script pasted into the editor.');
    } else {
        displayErrorMessage('Unable to paste the macro script into the interface.');
    }
}

/**
 * Scrolls the chat log to the bottom to ensure the latest content is visible.
 */
export function scrollChatToBottom() {
    const chatLog = document.getElementById('chat-log');
    chatLog.scrollTop = chatLog.scrollHeight;
}

/**
 * Displays an error message in the chat log.
 * @param {string} message - The error message to display.
 */
export function displayErrorMessage(message) {
    displayMessage(message, 'error-message');
}

/**
 * Displays a success message in the chat log.
 * @param {string} message - The success message to display.
 */
export function displaySuccessMessage(message) {
    displayMessage(message, 'success-message');
}

/**
 * Displays a message in the chat log with a specific class.
 * @param {string} message - The message to display.
 * @param {string} className - The CSS class for styling the message.
 */
function displayMessage(message, className) {
    const chatLog = document.getElementById('chat-log');
    const messageDiv = document.createElement('div');
    messageDiv.className = className;
    messageDiv.textContent = message;
    chatLog.appendChild(messageDiv);
    scrollChatToBottom();
    setTimeout(() => messageDiv.remove(), 5000);
}

/**
 * Shows the loading indicator in the chat log.
 */
export function showLoadingIndicator() {
    const chatLog = document.getElementById('chat-log');
    let loadingDiv = chatLog.querySelector('.loading-indicator');
    if (!loadingDiv) {
        loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading-indicator';
        loadingDiv.textContent = 'Generating...';
        chatLog.appendChild(loadingDiv);
    }
    scrollChatToBottom();
}

/**
 * Hides the loading indicator in the chat log.
 */
export function hideLoadingIndicator() {
    const loadingDiv = document.querySelector('.loading-indicator');
    if (loadingDiv) loadingDiv.remove();
}

/**
 * Updates the input area with streamed content.
 * @param {string} content - The content to update the input area with.
 */
export function updateInputArea(content) {
    const userInput = document.getElementById('user-input');
    userInput.value = content;
    adjustTextareaHeight(userInput);
}

/**
 * Adjusts the height of the textarea to fit the content.
 * @param {HTMLTextAreaElement} textarea - The textarea element to adjust.
 */
export function adjustTextareaHeight(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = `${textarea.scrollHeight}px`;
}


/**
 * Displays structured results or additional information in the chat log.
 * @param {Object|string} data - The data to display. Can be an object or a string.
 * @param {string} [title='Results'] - Optional title for the results section.
 */
export function displayResults(data, title = 'Results') {
    const chatLog = document.getElementById('chat-log');
    const resultsDiv = document.createElement('div');
    resultsDiv.className = 'results-message output-bubble';

    let content = '';
    if (typeof data === 'object') {
        content = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
    } else {
        content = `<p>${data}</p>`;
    }

    resultsDiv.innerHTML = `
        <div class="results-header">${title}</div>
        <div class="results-content">${content}</div>
    `;

    chatLog.appendChild(resultsDiv);
    scrollChatToBottom();
}


===== app/static/js/utils.js =====

/**
 * @file utils.js
 * @description Utility functions for the Atlas application.
 * @module utils
 */

/**
 * Adjusts the height of a textarea to fit its content.
 * @param {HTMLTextAreaElement} textarea - The textarea element to adjust.
 */
export function adjustTextareaHeight(textarea) {
    // Reset height to auto to get the correct scrollHeight
    textarea.style.height = 'auto';
    // Set the height to the scrollHeight
    textarea.style.height = textarea.scrollHeight + 'px';
}

/**
 * Creates a debounced function that delays invoking `func` until after `wait` milliseconds have elapsed since the last time the debounced function was invoked.
 * @param {Function} func - The function to debounce.
 * @param {number} wait - The number of milliseconds to delay.
 * @returns {Function} The debounced function.
 */
export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Generates a unique identifier.
 * @returns {string} A unique identifier string.
 */
export function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

/**
 * Safely parses JSON, returning null if parsing fails.
 * @param {string} jsonString - The JSON string to parse.
 * @returns {Object|null} The parsed object or null if parsing failed.
 */
export function safeJSONParse(jsonString) {
    try {
        return JSON.parse(jsonString);
    } catch (error) {
        console.error('Error parsing JSON:', error);
        return null;
    }
}

/**
 * Truncates a string to a specified length, appending an ellipsis if truncated.
 * @param {string} str - The string to truncate.
 * @param {number} maxLength - The maximum length of the string.
 * @returns {string} The truncated string.
 */
export function truncateString(str, maxLength) {
    if (str.length <= maxLength) return str;
    return str.slice(0, maxLength - 3) + '...';
}

/**
 * Escapes HTML special characters in a string.
 * @param {string} unsafe - The string with potentially unsafe HTML.
 * @returns {string} The string with HTML special characters escaped.
 */
export function escapeHTML(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

/**
 * Formats a date object to a string in the format "YYYY-MM-DD HH:MM:SS".
 * @param {Date} date - The date to format.
 * @returns {string} The formatted date string.
 */
export function formatDate(date) {
    return date.toISOString().replace('T', ' ').substr(0, 19);
}


===== app/templates/index.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FijiAI - ImageJ Macro Execution and Chat</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
    <link rel="stylesheet" href="static/css/main.css">
    <link rel="stylesheet" href="static/css/colors.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js" defer></script>
</head>

<body>
    <div class="container">
        <!-- Sidebar for Image Previews -->
        <div class="sidebar collapsed" id="sidebar">
            <div class="sidebar-toggle" id="sidebar-toggle">
                <img src="/static/icons/toggle.png" alt="Toggle Sidebar">
            </div>
            <div class="sidebar-content">
                <div id="image-preview-container"></div>
            </div>
        </div>

        <!-- Left Column: ImageJ Macro Execution -->
        <div class="left-column">
            <h2>ImageJ Macro Execution</h2>
            <div id="drop-zone" class="drop-zone">
                <p>Drag and drop images here or click to select files</p>
            </div>
            <form id="image-upload-form" action="/upload-image/" method="post" enctype="multipart/form-data">
                <input type="file" id="images" name="files" multiple accept="image/*" style="display: none;">
                <div id="macro-preview-container" class="image-previews"></div>
                <textarea name="macro_script" id="macro_script" rows="10"
                    placeholder="Enter macro script..."></textarea>
                <button type="submit" id="upload-btn" name="upload-btn">Upload Images and Execute Macro</button>
            </form>
            <div id="spinner-container" class="spinner-container" style="display: none;">
                <div class="spinner"></div>
                <p>Processing images... Please wait.</p>
            </div>
            <div id="execution-results"></div>
        </div>

        <!-- Right Column: Chat Interface -->
        <div class="right-column">
            <h2>Design Custom ImageJ Workflows with Atlas</h2>
            <div class="chat-container">
                <div id="chat-log-container" class="chat-log">
                    <div id="chat-log"></div>
                </div>
                <form id="chat-form" action="/stream_generate_macro/" method="post">
                    <div class="chat-input-container">
                        <button type="button" id="attach-btn" class="attach-icon">
                            <img src="/static/icons/paperclip.png" alt="Attach">
                        </button>
                        <textarea id="user-input" name="input" placeholder="Ask Atlas a question"></textarea>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="improve-prompt" name="improve_prompt">
                            <label for="improve-prompt" style="margin-left: 5px;">Improve prompt?</label>
                        </div>
                        <!-- Added Model Choice Dropdown -->
                        <div style="display: flex; align-items: center; margin-left: 10px;">
                            <label for="model-choice" style="margin-right: 5px;">AI Model:</label>
                            <select id="model-choice" name="model_choice">
                                <option value="anthropic">Anthropic Claude</option>
                                <option value="openai">OpenAI GPT-4o</option>
                            </select>
                        </div>
                        <button type="submit" id="chat-submit-btn">
                            <img src="/static/icons/send.png" alt="Send">
                        </button>
                    </div>
                    <input type="file" id="chat-file-input" accept="image/*" style="display: none;">
                </form>
            </div>
        </div>

        <!-- Dropdown for Color Scheme Selection -->
        <div class="color-scheme-selector">
            <label for="color-scheme-select">Choose a color scheme:</label>
            <select id="color-scheme-select">
                <option value="complementary">Complementary</option>
                <option value="analogous">Analogous</option>
                <option value="triadic">Triadic</option>
                <option value="split-complementary">Split-Complementary</option>
                <option value="monochromatic">Monochromatic</option>
                <option value="nature">Nature-Inspired</option>
                <option value="pastel">Pastel</option>
                <option value="neon">Neon</option>
                <option value="earthy">Earthy</option>
                <option value="dark-luxury">Dark Luxury</option>
                <option value="light-complementary">Light Complementary</option>
                <option value="light-analogous">Light Analogous</option>
                <option value="light-triadic">Light Triadic</option>
                <option value="light-split-complementary">Light Split-Complementary</option>
                <option value="light-monochromatic">Light Monochromatic</option>
                <option value="light-default">Light Default</option>
            </select>
        </div>

        <!-- JS Scripts -->
        <script type="module" src="/static/js/main.js"></script>
        <script type="module" src="/static/js/colorSchemeSwitcher.js"></script>
</body>

</html>


===== app/templates/macros/headless_macro_template.ijm =====

// Variables will be inserted here by the Python script
// var inputPath = "/path/to/input/file";
// var outputDir = "/path/to/output/directory/";
// var originalFileName = "original_file_name.czi";
// var minSize = 10;
// var maxSize = "Infinity";
// var minCircularity = 0.00;
// var maxCircularity = 1.00;

// Function to log output files and directories
function logOutput(key, value) {
    File.append(key + ": " + value + "\n", outputDir + File.separator + "output_log.txt");
}

// Define subdirectories
imagesDir = "Images";
statisticsDir = "Statistics";
metadataDir = "Metadata";

// Create output directories
File.makeDirectory(outputDir + File.separator + imagesDir);
File.makeDirectory(outputDir + File.separator + statisticsDir);
File.makeDirectory(outputDir + File.separator + metadataDir);

// Log subdirectories
logOutput("IMAGES_DIR", imagesDir);
logOutput("STATISTICS_DIR", statisticsDir);
logOutput("METADATA_DIR", metadataDir);

// Enable Bio-Formats Macro Extensions
run("Bio-Formats Macro Extensions");

// Initialize the file
Ext.setId(inputPath);
Ext.getSeriesCount(seriesCount);
Ext.getSizeX(width);
Ext.getSizeY(height);
Ext.getSizeC(channels);
Ext.getSizeZ(slices);
Ext.getSizeT(frames);
Ext.getPixelType(pixelType);

// Extract essential metadata
Ext.getImageCreationDate(creationDate);

// Open the image
Ext.openImagePlus(inputPath);

// Log image information
IJ.log("IMAGE_INFO_START");
IJ.log(originalFileName + "," + width + "," + height + "," + channels + "," + slices + "," + frames + "," + pixelType);
IJ.log("IMAGE_INFO_END");

// Log metadata
logOutput("WIDTH", width);
logOutput("HEIGHT", height);
logOutput("CHANNELS", channels);
logOutput("SLICES", slices);
logOutput("FRAMES", frames);
logOutput("PIXEL_TYPE", pixelType);
logOutput("CREATION_DATE", creationDate);

// Save metadata to a file
metadataPath = outputDir + File.separator + metadataDir + File.separator + originalFileName + "_metadata.txt";
metadataContent = "Original File: " + originalFileName + "\n" +
                  "Dimensions: " + width + "x" + height + "x" + channels + "x" + slices + "x" + frames + "\n" +
                  "Pixel Type: " + pixelType + "\n" +
                  "Creation Date: " + creationDate + "\n";

// Check if a metadata file with the same content already exists
existingFiles = getFileList(outputDir + File.separator + metadataDir);
metadataExists = false;
for (i = 0; i < existingFiles.length; i++) {
    if (startsWith(existingFiles[i], originalFileName)) {
        existingPath = outputDir + File.separator + metadataDir + File.separator + existingFiles[i];
        if (File.exists(existingPath)) {
            existingContent = File.openAsString(existingPath);
            if (existingContent == metadataContent) {
                metadataExists = true;
                break;
            }
        }
    }
}

if (!metadataExists) {
    File.saveString(metadataContent, metadataPath);
    logOutput("OUTPUT_FILE", metadataPath);
    print("Saved metadata: " + metadataPath);
} else {
    print("Metadata file with same content already exists. Skipping creation.");
}
//


// User-provided macro script starts here
{user_macro}



// Close all images
run("Close All");

IJ.log("MACRO_EXECUTION_COMPLETED");


===== app/templates/macros/conversion_macro.ijm =====

function logOutput(key, value) {{
    print(key + ": " + value);
    File.append(key + ": " + value, "{output_log_path}");
}}

setBatchMode(true);
run("Bio-Formats Macro Extensions");

print("Initializing file: {input_path}");
Ext.setId("{input_path}");
Ext.getSeriesCount(seriesCount);
print("Series count: " + seriesCount);

if (seriesCount == 0) {{
    logOutput("ERROR", "Failed to read the image file");
    exit("Macro canceled");
}}

Ext.getSizeX(width);
Ext.getSizeY(height);
Ext.getSizeC(channels);
Ext.getSizeZ(slices);
Ext.getSizeT(frames);
Ext.getPixelType(pixelType);
Ext.getImageCreationDate(creationDate);

print("Image dimensions: " + width + "x" + height + "x" + channels + "x" + slices + "x" + frames);

print("Opening image with Bio-Formats");
Ext.openImagePlus("{input_path}");

if (nImages == 0) {{
    logOutput("ERROR", "Failed to open the image with Bio-Formats");
    exit("Macro canceled");
}}

originalID = getImageID();
print("Opened original image with ID: " + originalID);

run("8-bit");

// Generate Maximum Intensity Projection
if (slices > 1) {{
    run("Z Project...", "projection=[Max Intensity]");
}}

// Enhance contrast
for (c = 1; c <= channels; c++) {{
    Stack.setChannel(c);
    run("Enhance Contrast", "saturated=0.35");
}}

if (channels > 1) {{
    run("Make Composite");
}}

// Save the MIP as a TIFF
previewPath = "{output_dir}" + File.separator + "preview_{filename}";

// Remove any existing file extension before appending ".tif"
if (previewPath.contains(".")) {{
    previewPath = previewPath.substring(0, previewPath.lastIndexOf('.'));
}}

previewPath += ".tif";  // Ensuring the correct extension
saveAs("Tiff", previewPath);
logOutput("PREVIEW_PATH", previewPath);

// Save metadata
metadata = "Original File: " + "{filename}" + "\\n" +
        "Dimensions: " + width + "x" + height + "x" + channels + "x" + slices + "x" + frames + "\\n" +
        "Pixel Type: " + pixelType + "\\n" +
        "Creation Date: " + creationDate;
metadataPath = "{output_dir}" + File.separator + "{filename}_metadata.txt";
File.saveString(metadata, metadataPath);
logOutput("METADATA_PATH", metadataPath);

close();

setBatchMode(false);
print("Macro execution completed.");


===== app/auth.py =====

"""
Authentication module for the FastAPI application.
Provides user authentication using HTTP Basic Auth.
"""

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from werkzeug.security import check_password_hash
from .config import load_config

# Load configuration
config = load_config()

# Set up HTTP Basic Auth
security = HTTPBasic()

# User credentials (in production, use a more secure method)
users = {config.get('auth.username'): config.get('auth.password')}

def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):
    """
    Validate user credentials and return the username if valid.

    Args:
        credentials (HTTPBasicCredentials): The credentials provided in the request.

    Returns:
        str: The username if credentials are valid.

    Raises:
        HTTPException: If credentials are invalid.
    """
    correct_username = credentials.username in users
    correct_password = check_password_hash(users.get(credentials.username, ''), credentials.password)
    if not (correct_username and correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username

===== app/config.py =====

"""
Configuration module for the FastAPI application.
Handles loading and accessing configuration from a YAML file.
"""

import os
import yaml

class Config:
    """Configuration class to load and access config data."""

    def __init__(self, config_file=None):
        """
        Initialize the Config object.

        Args:
            config_file (str, optional): Path to the config file. If None, uses default path.
        """
        if config_file is None:
            config_file = os.path.join(os.path.dirname(__file__), '..', 'config.yaml')
        self.config_file = config_file
        self.config_data = self.load_config()

    def load_config(self):
        """
        Load configuration from YAML file.

        Returns:
            dict: Loaded configuration data.

        Raises:
            FileNotFoundError: If the config file is not found.
            Exception: If there's an error parsing the YAML file.
        """
        if not os.path.exists(self.config_file):
            raise FileNotFoundError(f"Configuration file not found: {self.config_file}")
        
        with open(self.config_file, 'r') as file:
            try:
                return yaml.safe_load(file)
            except yaml.YAMLError as e:
                raise Exception(f"Error parsing the configuration file: {str(e)}")

    def get(self, key, default=None):
        """
        Get a configuration value by key.

        Args:
            key (str): Dot-separated key to access nested config values.
            default: Value to return if the key is not found.

        Returns:
            The value associated with the key, or the default value.

        Raises:
            KeyError: If the key is not found and no default is provided.
        """
        keys = key.split('.')
        value = self.config_data
        
        try:
            for k in keys:
                value = value[k]
            return value
        except KeyError:
            if default is not None:
                return default
            raise KeyError(f"Configuration key not found: {key}")

def load_config():
    """
    Load the configuration file.

    Returns:
        Config: Initialized Config object.
    """
    config_file = os.path.join(os.path.dirname(__file__), '..', 'config.yaml')
    return Config(config_file)

===== app/database.py =====

from sqlalchemy import create_engine, Column, Integer, String, JSON, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import load_config

config = load_config()

# Database connection string
DATABASE_URL = config.get('database_url', 'sqlite:///./fijiAI.db')

# Create SQLAlchemy engine
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})

# Create a session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create a base class for declarative models
Base = declarative_base()

class ImageMetadata(Base):
    """
    Model for storing image metadata.
    """
    __tablename__ = "image_metadata"

    id = Column(Integer, primary_key=True, index=True)
    file_name = Column(String, unique=True, index=True)
    image_metadata = Column("metadata", JSON)  # Note the use of "metadata" as the actual column name
    original_path = Column(Text)  # Field to store the path of the original file
    preview_path = Column(Text)  # Field to store the path of the preview file
    original_file_type = Column(String)  # Field to store the original file type
    file_type = Column(String)  # Add this line to include file_type

def get_db():
    """
    Get a database session.

    Yields:
        Session: A SQLAlchemy database session.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Update the table to reflect the changes in the model
Base.metadata.drop_all(bind=engine, tables=[ImageMetadata.__table__])
Base.metadata.create_all(bind=engine, tables=[ImageMetadata.__table__])


===== app/__init__.py =====

import logging
import os
import asyncio
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.responses import HTMLResponse
from starlette.requests import Request
from .config import load_config
from .services import imagej_service, image_service, file_service
from .routes import image_routes, chat_routes

class AtlasApplication:
    def __init__(self):
        """
        Initializes the Atlas application by setting up FastAPI, configuration,
        logging, and ImageJ service.
        """
        self.app = FastAPI()
        self.config = load_config()
        self.logger = self._setup_logging()
        self.imagej_service = imagej_service  # Use the instantiated service
        self.templates = None
        self.macro_template = None
        self.PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.IJ = None
        self.BF = None

    def _setup_logging(self):
        """
        Sets up the logging configuration for the application.
        """
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        logger.info("Logging is set up.")
        return logger

    def _mount_static_files(self):
        """
        Mounts static files for the application.
        """
        static_dir = os.path.join(self.PROJECT_ROOT, self.config.get('paths.static_dir', 'app/static'))
        if os.path.exists(static_dir):
            self.app.mount("/static", StaticFiles(directory=static_dir), name="static")
            self.logger.info(f"Static files directory mounted: {static_dir}")
        else:
            self.logger.warning(f"Static files directory does not exist: {static_dir}")

    def _setup_templates(self):
        """
        Sets up template rendering for the application.
        """
        template_dir = os.path.join(self.PROJECT_ROOT, self.config.get('paths.template_dir', 'app/templates'))
        if os.path.exists(template_dir):
            self.templates = Jinja2Templates(directory=template_dir)
            self.logger.info(f"Template directory set: {template_dir}")
        else:
            self.logger.error(f"Template directory does not exist: {template_dir}")
            raise RuntimeError(f"Template directory does not exist: {template_dir}")

    def _load_macro_template(self):
        """
        Loads the macro template from the specified path in the configuration.
        """
        macro_template_path = self.config.get('paths.macro_template')
        if os.path.exists(macro_template_path):
            with open(macro_template_path, 'r') as template_file:
                self.macro_template = template_file.read()
            self.logger.info(f"Macro template loaded from: {macro_template_path}")
        else:
            self.logger.error(f"Macro template does not exist at: {macro_template_path}")
            raise RuntimeError(f"Macro template does not exist at: {macro_template_path}")

    def _include_routers(self):
        """
        Includes all route handlers into the FastAPI application.
        """
        self.app.include_router(image_routes.router)
        self.app.include_router(chat_routes.router)
        self.logger.info("Routers included successfully.")

    async def startup_event(self):
        """
        Initializes the ImageJ service during the application startup.
        """
        try:
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, self.imagej_service.initialize)
            self.IJ, self.BF = self.imagej_service.get_imagej_objects()
            self.logger.info("ImageJ initialized successfully.")
        except Exception as e:
            self.logger.error(f"Failed to initialize ImageJ: {str(e)}")
            raise RuntimeError("Critical error during startup: Failed to initialize ImageJ")

    async def shutdown_event(self):
        """
        Shuts down the ImageJ service during the application shutdown.
        """
        try:
            await asyncio.get_event_loop().run_in_executor(None, self.imagej_service.shutdown)
            self.logger.info("ImageJ shut down successfully.")
        except Exception as e:
            self.logger.error(f"Failed to shut down ImageJ: {str(e)}")

    def create_app(self):
        """
        Assembles the FastAPI application by mounting static files, setting up templates,
        including routers, and configuring event handlers.
        """
        self._mount_static_files()
        self._setup_templates()
        self._load_macro_template()
        self._include_routers()
        self.app.add_event_handler("startup", self.startup_event)
        self.app.add_event_handler("shutdown", self.shutdown_event)
        self._setup_root_endpoint()
        self.logger.info("Application created successfully.")
        return self.app

    def _setup_root_endpoint(self):
        """
        Sets up the root endpoint for serving the main page.
        """
        @self.app.get("/", response_class=HTMLResponse)
        async def read_root(request: Request):
            """Serve the main page."""
            return self.templates.TemplateResponse("index.html", {"request": request})


# Usage
atlas_app = AtlasApplication()
app = atlas_app.create_app()


===== app/main.py =====

"""
Main module for the FastAPI application.
"""

import uvicorn
from . import app

if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)


===== config.yaml =====

# FijiAI Configuration

# Application settings
app:
  secret_key: 'your_secret_key'
  debug: true

# Paths
paths:
  imagej_dir: '/home/alex/ImageJ_Project/Fiji.app'
  bioformats_dir: '/home/alex/ImageJ_Project/Fiji.app/plugins/bio-formats_plugins-7.3.1.jar'
  template_dir: 'app/templates'
  static_dir: 'app/static'
  upload_dir: 'app/uploads'
  macro_template: 'app/templates/macros/headless_macro_template.ijm'
  conversion_template: 'app/templates/macros/conversion_macro.ijm'

# API keys
api_keys:
  anthropic: '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'
  openai: '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'

# Authentication
auth:
  username: 'admin'
  password: 'pbkdf2:sha256:260000$1lgFgvjdKQGinWz1$2f50b533c0ed222b243c69a460e65b2df972748592151f0d49d045ea1e5d95f0'

# Logging
logging:
  level: 'INFO'
  format: '%(asctime)s - %(levelname)s - %(message)s'

# ImageJ settings
imagej:
  mode: 'headless'

# AI model settings
claude:
  model: 'claude-3-5-sonnet-20240620'
  max_tokens: 2500

openai:
  model: 'gpt-4o-2024-08-06'
  max_tokens: 2500


===== app/prompts/__init__.py =====



===== app/prompts/system_prompts.py =====

MACRO_GENERATION_PROMPT = """<system_instructions>
You are an expert in generating ImageJ macros (.ijm) for complex image analysis workflows in the FijiAI system, specializing in headless operation. When asked to create a macro, provide:

- A clear description prefixed with **[DESCRIPTION]**.
- The macro script enclosed within
javascript code blocks.
- An explanation prefixed with **[EXPLANATION]**.

Ensure responses are formatted for clear UI updates.

**CRITICAL GUIDELINES:**

1. **Main Variables (DO NOT redefine):**
   - inputPath, outputDir, originalFileName, width, height, channels, slices, frames, minSize, maxSize, minCircularity, maxCircularity, imagesDir, statisticsDir, metadataDir.

2. **Image Handling:**
   - The main image is already open; do not open or close it.
   - Use selectImage() with image IDs obtained via getImageID().
   - Capture image IDs immediately after creation or duplication.

3. **Processing Workflow:**
   - **Order of Operations is Vital:**
     - Perform thresholding before particle analysis.
     - Avoid converting images to binary unless explicitly requested.
     - Retain original intensity values during processing.
   - **Per Channel Processing:**
     - Loop through each channel:
       - Duplicate the channel stack when needed.
       - Apply processing steps (e.g., thresholding, filtering).
       - Perform particle analysis directly after thresholding on grayscale images.
       - Save results with descriptive filenames including the channel and processing details.
       - Close temporary images to manage memory.
   - **Optional Multi-Method Testing:**
     - If multiple methods are to be tested (e.g., thresholding techniques), loop through methods and repeat processing steps.
     - Ensure results are labeled with the method used.

4. **Result Saving:**
   - Use File.separator for path construction.
   - Save intermediate and final results with clear, descriptive filenames.
   - Log saved files with print("OUTPUT_FILE: " + filePath).

5. **Memory and File Management:**
   - Close temporary images after use.
   - Delete intermediate files when no longer needed; log deletions with print("Deleted intermediate file: " + filePath).

6. **Post-Processing:**
   - Merge processed channels if required.
   - Convert to hyperstack when appropriate, specifying correct dimensions.
   - Apply additional processing steps as specified by the user.

7. **Logging and Optimization:**
   - Provide detailed logs for each major step.
   - Ensure headless compatibility and optimize for large datasets.
   - Apply operations across entire stacks efficiently.

**GENERAL MACRO STRUCTURE EXAMPLE:**

javascript
// Initialize
setBatchMode(true);
originalID = getImageID();
print("Processing image with ID: " + originalID);

// Loop through channels (and methods if applicable)
for (method in methods) {
    for (c = 1; c <= channels; c++) {
        selectImage(originalID);
        // Duplicate channel stack
        run("Duplicate...", "title=Channel_" + c + "_Method_" + method + " duplicate channels=" + c);
        channelID = getImageID();

        // Apply processing steps
        setAutoThreshold(method + " dark");
        // Do not convert to binary to retain intensity values

        // Perform particle analysis
        run("Set Measurements...", "area mean integrated min stack");
        run("Analyze Particles...", "size=" + minSize + "-" + maxSize + " circularity=" + minCircularity + "-" + maxCircularity + " show=Outlines display include summarize stack");

        // Save results
        resultsPath = outputDir + File.separator + statisticsDir + File.separator + originalFileName + "_Channel" + c + "_Method_" + method + "_Results.csv";
        saveAs("Results", resultsPath);
        print("OUTPUT_FILE: " + resultsPath);

        // Close temporary images
        selectImage(channelID);
        close();
    }
}

// Post-processing steps if required

setBatchMode(false);
print("Processing complete!");

REMEMBER:

-Maintain original grayscale values unless a binary image is specifically requested.
-The order of operations is critical for accurate measurements.
-Only include functions explicitly requested by the user.
-Provide suggestions for additional analyses separately from the macro code.
-Ensure the macro fits within the {user_macro} section of the template.

</system_instructions>
"""

PROMPT_IMPROVEMENT_SYSTEM = """
You are an expert in refining user prompts for ImageJ macro generation in the FijiAI system. Your task is to enhance the user's input to create a clear, detailed prompt that aligns with the application's capabilities without altering the user's desired outcomes.

Focus on:

- Clarifying the desired analysis, specifying exact measurements and processing steps.
- Ensuring alignment with FijiAI's headless compatibility guidelines.
- Maintaining the critical order of operations for accurate results.
- Highlighting the importance of preserving intensity information by avoiding unnecessary conversion to binary images.
- Advising on the use of duplicates when necessary to preserve original data.
- Emphasizing efficient, stack-aware operations for multi-channel z-stack images.
- Organizing steps logically for seamless execution and data integrity.
- Including necessary parameters and considerations for functions like thresholding and particle analysis.
- Advising on proper naming, saving, and memory management practices.
- Ensuring the prompt encourages the use of descriptive filenames and thorough logging.

Return only the improved prompt, ready for macro generation, without additional explanations.
"""

PROMPT_IMPROVEMENT_USER = """
Please improve the following prompt for ImageJ macro generation:

{user_input}

Enhance the prompt by making it more detailed and specific, focusing on the points mentioned in the system instructions. Ensure it outlines a clear, logical sequence of processing steps, efficiently handling multi-channel z-stack images, and adheres to headless compatibility guidelines. Do not alter the desired outcomes or processing steps.

Include considerations for:

- Preserving intensity data by avoiding unnecessary conversions.
- The critical order of operations, especially regarding thresholding and particle analysis.
- When and why to duplicate images during processing.
- Proper memory management and logging practices.
- Descriptive naming conventions for files.

Return only the improved prompt without additional explanations.
"""


